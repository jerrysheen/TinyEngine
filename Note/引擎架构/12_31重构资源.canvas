{
	"nodes":[
		{"id":"235142002b3a3910","type":"text","text":"Texture2D\n","x":-670,"y":31,"width":290,"height":129},
		{"id":"8f266463f7ecc4b7","type":"text","text":"FrameBuffer\nColorAttachment Texture2D\nDepthAttachment Texture2D","x":-705,"y":280,"width":360,"height":129},
		{"id":"8cd4cafd95cbcbc9","type":"text","text":"Mesh:\nIndexBuffer\nVertexBuffer\n","x":-255,"y":35,"width":290,"height":129},
		{"id":"c981dbff274ead5f","type":"text","text":"IGPUView*\nuav srv\nrtv","x":-90,"y":-440,"width":250,"height":170},
		{"id":"529c41e208392b87","type":"text","text":"IGPUResource*\n长宽高、 资源状态、资源用途、IGPUBuffer基本的类型","x":-470,"y":-490,"width":250,"height":220},
		{"id":"dd2bd8fd28bb9c7d","x":496,"y":-487,"width":1064,"height":1347,"type":"text","text":"# MaterialInstance 重构：\n其实这一套， 左边的部分都是代码实现而已，但是这边这一部分描述了一些现在引擎的问题，需要厘清一下：\n1.  为什么我们需要 MaterialInstance + MaterialLayout的结构。有两个原因：\n\t1. 因为我们用了ByteAddressBuffer，hlsl中手动获取位移，没有了Cbuffer的反射\n\t2. MaterialInstance是一个连续内存块，通过C++端定义 offset和length，能够更快的更新数据并且同步，去掉原先通过Reflection+反射导致的性能问题。\n2. 这个结构体导致的一些问题：\n\t1. 首先最直观的问题就是，写shader复杂度提升，原先通过反射让C++ hlsl直接同步数据的甜点模式消失了，取而代之的是需要两端约定的写法，并且用户不友好\n\t2. 我们需要多套Layout，比如PBR一套，阴影一套。这也牵扯出另外一个问题，**Blit这种内置shader怎么办**\n### 要解决这个问题，我们来回顾下RenderAPI + 现在的渲染端的演进：\n1. 第一版本，C++端就是反射，维护自己的数据Cbuffer，然后CPU更新到GPU，绘制。\n2. 第二个版本，C++端按照更新频率分成perDraw perMaterial perframe，并且严格定义slot和space，让绑定更加简单\n3. 第三个版本，加入SRP Batch + instancing， 加入instanceDataBuffer，排序sorting后，每个Batch有自己的instanceDataIndex，里面记录了比如50个物体渲染的index，所有的PerDraw数据变成了PerObjectData，并且放在一个统一的大buffer里面，像是**objectToWorldMaterix**。 同时PerMaterial数据也放在了一个大buffer里面，通过hlsl手动解码byteaddressbuffer的方式做。从这个地方开始，形成了和原先设计的一些矛盾冲突。\n4. 第四个版本，加入GPUScene，GPU Culling + DrawIndirectArgsbuffer，数据层设计基本兼容，依然有一个instanceDataIndexBuffer（visibilitybuffer），并且为GPUScene创建了一个 AABB + RenderProxy 的数据结构 + CullingParam，大致就是采用简介寻址的方式，首先GPU Culling 根据AABB + CullingParam，对单个物体是否需要渲染进行判断，如果需要，则从PerObjectData里面找到他对应的RenderProxy位置，可能一个物体需要渲染多个pass，对应多个BatchID，找到对应的BatchID之后，用InternalADD，在对应的instanceDataIndexBuffer记录下当前渲染物体的Index。\n\t渲染的时候，DrawIndirectArgsBuffer知道物体渲染的mesh，然后它发起指令ExecuteInDirect，和DrawInstance类似，其实就是发起一次index 从0 ~ count的指令， svInstanceID为0~count，剩下的都是shader里面去根据 startIndex + svInstanceID找到对应的 instanceDataIndex， 再找到PerObjectDataIndex，再间接根据其中的RenderProxy找到BatchID，找到对应的材质。\n5. 回到下一个Bindless版本，可以看到上面的设计大部分能沿用，我们主要需要修改Texture绑定方式，以及怎么兼容一些内建的比如BlitShader：\n\t1. bindless版本下， texture和buffer，不再绑定在slot，而是绑定在GLobalheap中， 通过index间接寻址寻找到对应的资源，直接在hlsl中进行取值。\n\t2. 因此未来，textureDescriptorID会作为一个材质信息，放到MaterialInstance中，shader中直接通过index拿具体数据。\n\t3. 如何针对BlitShader做优化，因为blitshader不需要走我们默认这套，我们应该修改引擎让它支持直接从CPU端发渲染API的功能，比如BlitShader可能就是 setRootSig + bindTexture + SetCbuffer + draw。 我们之前忽略了这一层，RenderPass不具备发送底层API的能力，而是将RenderPass层纯粹当成配置，收集Batch的工具，这个结构需要修改下。这也是能够简化我们代码的一种方式，未来我们的结构，针对场景物体，用GPUScene驱动渲染，针对一些后处理pass，则可以通过简单API调用来实现绘制。\n### AI对话后的启示：\nhttps://chatgpt.com/c/695cc431-a880-8324-a8a2-30876fc6db84\n1. 会有一些方式来解决当前写shader不友好的问题，可以加入feature\n2. 可能不需要多个pass多个Layout，一个Layout里包含shadow + pbr试试 \n3. RenderPass可能需要重构，目前只做资源收集，我们需要有指令发射的能力 【done】\n\n\n\n## 下一步重构的起点：\nRenderPass拆分 done了\n现在开始做Texture的绑定逻辑。"},
		{"id":"017ec312e5d8a84c","x":1885,"y":-99,"width":250,"height":60,"type":"text","text":"## Review DescHeap：\n这个地方注意，为了兼容Lagacy，我们只需要一个 PerfarmeHeapAllocator和 保留CPU Address即可！\n"}
	],
	"edges":[
		{"id":"c73a05f85dfe4a0d","fromNode":"235142002b3a3910","fromSide":"top","toNode":"529c41e208392b87","toSide":"bottom"},
		{"id":"64b97ca11ccf7e5e","fromNode":"235142002b3a3910","fromSide":"top","toNode":"c981dbff274ead5f","toSide":"bottom"},
		{"id":"dda9dece37622f71","fromNode":"8f266463f7ecc4b7","fromSide":"top","toNode":"235142002b3a3910","toSide":"bottom"},
		{"id":"9fe99c537b08d3c8","fromNode":"8cd4cafd95cbcbc9","fromSide":"top","toNode":"529c41e208392b87","toSide":"bottom"},
		{"id":"74f2146a05c9cd7b","fromNode":"8cd4cafd95cbcbc9","fromSide":"top","toNode":"c981dbff274ead5f","toSide":"bottom"}
	]
}