{
	"nodes":[
		{"id":"19edc58931d3b37d","type":"text","text":"void ScriptableRenderContext::Submit()\n{\n    ExecuteScriptableRenderLoop();\n}\n","x":-1240,"y":-127,"width":360,"height":117},
		{"id":"dfca92f0e16b6da7","type":"text","text":"入口函数： 从URP中调用过来","x":-1197,"y":-220,"width":275,"height":60},
		{"id":"eaa43445e01b567d","type":"text","text":"C#：\ncontext->submit","x":-1660,"y":-98,"width":250,"height":60},
		{"id":"7443fc37a1b62e23","type":"text","text":"思路其实和我们的差不多， C#层推各种指令到SriptableRendererContext\n\n","x":-1787,"y":117,"width":507,"height":363},
		{"id":"91305142ae6a5668","type":"text","text":"```cpp\nvoid ScriptableRenderContext::ExecuteCommandBuffer(RenderingCommandBuffer& commandBuffer)\n{\n#if UNITY_EDITOR\n    commandBuffer.ValidateForSRP(m_IsInsideRenderPassForValidation);\n#endif\n\n    // Copy the command buffer to allow the passed in one to be cleared and reused\n    MemLabelRef memLabel = commandBuffer.GetMemLabel();\n    RenderingCommandBuffer* clonedCommandBuffer = UNITY_NEW(RenderingCommandBuffer, memLabel)(memLabel, commandBuffer);\n\n    UInt32 index = static_cast<UInt32>(m_CommandBuffers.size());\n    m_CommandBuffers.push_back(clonedCommandBuffer);\n    AddCommandWithIndex(kScriptRenderCommand_ExecuteCommandBuffer, index);\n}\n```\n","x":-1787,"y":600,"width":760,"height":440},
		{"id":"3bff69375bfbc9a7","type":"text","text":"```cpp\nvoid ScriptableRenderContext::DrawRenderers(ScriptableCullResults *cullResults, DrawingSettings const &drawSettings, FilteringSettings const &filterSettings, ShaderTagID tagName, bool isPassTagName, ShaderTagID const *tagValues, RenderStateBlock const *stateBlocks, int stateCount)\n{\n    RendererList rendererList = CreateRendererList(cullResults, drawSettings, filterSettings, tagName, isPassTagName, tagValues, stateBlocks, stateCount);\n\n    AddCommandWithIndex(kScriptRenderCommand_DrawRenderers, rendererList.index);\n}\n\n```","x":-985,"y":600,"width":785,"height":440},
		{"id":"414dfaa60a7fcfa3","type":"text","text":"Context.ExecuteCommandBuffer","x":-1557,"y":520,"width":300,"height":50},
		{"id":"a7ca02b47d854934","type":"text","text":"Context.ExecuteCommandBuffer","x":-742,"y":520,"width":300,"height":50},
		{"id":"216ad5c604b9060e","type":"text","text":"```cpp\n    dynamic_array<Command>  m_Commands;\n\n    dynamic_array<ShadowDrawingSettings>  m_DrawShadowCommands;\n    dynamic_array<DrawRenderersCommand> m_DrawRenderersCommands;\n    dynamic_array<RenderingCommandBuffer*> m_CommandBuffers;\n\n    dynamic_array<ScriptableRenderContextArg*> m_DrawRenderersData;\n```\n\n 看起来这个地方将数据放到了不同的地方去，Command中存一份， 后面的各种不同的Commands中存一份\n 看起来，数据会塞到具体的不同Commands array中， mCommands只是存Index+enum而已","x":-1787,"y":1080,"width":983,"height":280},
		{"id":"fdf05597abff8082","type":"text","text":"这么玩的好处：可以更好的多线程，不同的任务可以不用高度抽象成一个opcode\nopcode中可能只需要简单enum index表示是什么，在哪里就行，有利于多线程","x":-760,"y":1080,"width":274,"height":186},
		{"id":"af4e54458cd4be9a","type":"text","text":"","x":-61,"y":-220,"width":50,"height":1580},
		{"id":"ac73e7bd4fd2090b","type":"text","text":"Context.Submit()阶段","x":-136,"y":-320,"width":250,"height":60},
		{"id":"ac83567a9ae827c8","type":"text","text":"### Context.DrawShadows\n\n```cpp\nvoid ScriptableRenderContext::DrawShadows(const ShadowDrawingSettings& settings)\n{\n    UInt32 index = static_cast<UInt32>(m_DrawShadowCommands.size());\n    m_DrawShadowCommands.push_back(settings);\n    AddCommandWithIndex(kScriptRenderCommand_DrawShadows, index);\n}\n```\n看起来只是塞了一个渲染命令过来，并没有把数据塞过来","x":-1099,"y":117,"width":619,"height":363},
		{"id":"4d94a9907352f9e7","type":"text","text":"### ExecuteScriptableRenderLoop()\n\n```cpp\n        ScriptableRenderCommandType cmdType = (ScriptableRenderCommandType)m_Commands[i].type;\n        switch (cmdType)\n        {\n            case kScriptRenderCommand_DrawRenderers:\n            {\n                ScriptableRenderContextArg* drawRenderers = m_DrawRenderersData[m_Commands[i].perTypeIndex];\n                ExecuteDrawRenderersCommand(drawRenderers);\n                m_DrawRenderersCommands[m_Commands[i].perTypeIndex].status = kScheduleExecuted;\n                break;\n            }\n            case kScriptRenderCommand_DrawShadows:\n            {\n                const SlicedDrawShadow& sliceDrawShadow = drawShadowSliceData[m_Commands[i].perTypeIndex];\n                ExecuteDrawShadowsCommand(sliceDrawShadow);\n                break;\n            }\n```\n\n接下来就是消化生成的数据了，基本逻辑就是经过上面的处理后，数据被展开成了具体的RenderNode，存在了drawRenderer和sliceDrawShadow里面了。Command则是按照C#中我们往RenderContext里面录入的顺序执行的，我们只需要去遍历，处理就ok了。\n这样执行的Command都是按照顺序的。","x":80,"y":480,"width":1116,"height":560},
		{"id":"8422bccb8fc389fd","type":"text","text":"### ExecuteScriptableRenderLoop()\nSubmit之后跳转到这个逻辑， 主要处理这次录入的DrawCommand\nC#端发送简单的指令，比如Context.drawrenderers，Context.drawrenderers\n在C++层主线程负责处理这些Context中的command，然后产生具体的rendernode数据\n##### PrepareDrawShadowsCommandStep1\n根据Culling和灯光，去判断哪些物体要被剔除，哪些物体需要渲染\n##### PrepareDrawRenderersCommand\n根据culling结果，判断哪些物体需要被渲染，生成rendernode\n##### PrepareDrawShadowsCommandStep2\n根据step1中的结果，将需要渲染阴影的物体，生成rendernode\n\n相当于在C#层几个简单的指令，在这个地方被处理，膨胀成具体的需要渲染的rendernode数据\n","x":295,"y":-220,"width":686,"height":560},
		{"id":"ed31cf1a20210e75","type":"text","text":"","x":1435,"y":-190,"width":50,"height":1580},
		{"id":"8e3d2d77926448a1","type":"text","text":"处理具体ExecuteDrawRenderersCommand(drawRenderers)阶段","x":1230,"y":-300,"width":460,"height":80},
		{"id":"6edc1844a0a7ebd4","type":"text","text":"数据被发往多线程处理","x":1060,"y":-29,"width":208,"height":177},
		{"id":"d6b11efbbd3c1fed","type":"file","file":"Picture/Pasted image 20251128103006.png","x":3560,"y":29,"width":399,"height":104},
		{"id":"ea68e36e2c95d2ea","type":"text","text":"看起来两者是适配的？ 不 Instance 不走这个通路， 走","x":3635,"y":539,"width":250,"height":60},
		{"id":"e0103b3c4a79900c","type":"text","text":"void ScriptableBatchRenderer::RenderMultipleMeshes(const RenderNodeQueue& queue,","x":3760,"y":-251,"width":545,"height":100},
		{"id":"1de3bcb38ef87b11","type":"file","file":"Picture/Pasted image 20251128111249.png","x":3560,"y":201,"width":400,"height":188},
		{"id":"c81e3a3c0043a30f","type":"file","file":"Picture/Pasted image 20251128144237.png","x":4033,"y":29,"width":399,"height":102},
		{"id":"89d72dc2215ab008","type":"text","text":"ScriptableRenderLoopDrawSRPBatcher","x":2400,"y":425,"width":560,"height":50},
		{"id":"e9cd05fc6af29f8a","type":"text","text":"batchRenderer.Flush(kSRPBatchEndOfBatchFlush); ","x":2400,"y":575,"width":560,"height":60},
		{"id":"68cece06e9e319d6","type":"text","text":"void    ScriptableBatchRenderer::Flush(BatchBreakCause cause)","x":2400,"y":735,"width":560,"height":50},
		{"id":"f78019a0a9aa9592","type":"text","text":"这个地方首先可能需要厘清一下，什么数据在哪里更新？","x":2000,"y":-204,"width":542,"height":60},
		{"id":"a5e982f44a6b4173","type":"text","text":"device.ExecuteAsync(jobCount, ScriptableRenderLoopJob, ","x":2000,"y":-136,"width":542,"height":60},
		{"id":"751a889f7d9f6786","type":"text","text":"RenderShadowCasterPartsDispatch(GetGfxDevice(),","x":2041,"y":29,"width":461,"height":53},
		{"id":"c577a9d9df782ff6","type":"text","text":"ScriptableRenderLoopDrawDispatch：\n发送一组srpCompatible的node进行处理，\n以!SrpCompatible为结束\n","x":2041,"y":137,"width":461,"height":103},
		{"id":"1ef53e8f3bdc0256","type":"text","text":"ScriptableRenderLoopDrawSRPBatcher","x":1640,"y":430,"width":560,"height":50},
		{"id":"e0524a6106f7e079","type":"text","text":"batchRenderer.Flush(kSRPBatchEndOfBatchFlush); ","x":1640,"y":580,"width":560,"height":60},
		{"id":"2e180debab21a253","type":"text","text":"void    ScriptableBatchRenderer::Flush(BatchBreakCause cause)","x":1640,"y":740,"width":560,"height":50},
		{"id":"4849dc5a72b7016f","type":"text","text":"```cpp\n        else\n        {\n            if (resourceChange)\n            {\n                resourceChange = false;\n                if (!commandList->ApplyStateResources(m_Context.GetDevState(), &m_Context.GetResources()))\n                    return;    重要代码，这个地方重置\n            }\n\n            // Fast inner loop doing only \"draw\" (case where static batching is used)\n            for (int j = 0; j < int(batch->drawBufferRangesToConsume); j++)\n            {\n                const DrawBuffersRange& range = *drawBufferRangesIt;\n                const UInt32 instanceCount = std::max(range.instanceCount, 1u) * GetInstanceCountMultiplier();\n                const UInt32 firstInstance = 0;\n                cmdList->DrawIndexedInstanced(range.indexCount, instanceCount, buffers.indexBuffer->GetStride() == 4 ? range.firstIndexByte / 4 : range.firstIndexByte / 2, static_cast<SInt32>(range.baseVertex), firstInstance);\n                size_t triCount = GetPrimitiveCount(range.indexCount, range.topology, false);\n                GetFrameStats().AddDrawCall(triCount * instanceCount, range.vertexCount * instanceCount, j > 0);\n                drawBufferRangesIt++;\n            }\n        }\n```\n\n核心代码， 渲染一个Batch的时候，每次Resouce不同，就重新设置CBV SRV UAV\n\n# 接下来，看哪里在塞数据","x":3160,"y":649,"width":1280,"height":751}
	],
	"edges":[
		{"id":"ac1c08e21d28a70f","fromNode":"eaa43445e01b567d","fromSide":"right","toNode":"19edc58931d3b37d","toSide":"left"},
		{"id":"74bce36b5e058b83","fromNode":"8422bccb8fc389fd","fromSide":"bottom","toNode":"4d94a9907352f9e7","toSide":"top"},
		{"id":"569276499a59b33a","fromNode":"c577a9d9df782ff6","fromSide":"bottom","toNode":"89d72dc2215ab008","toSide":"top"},
		{"id":"ed5cefb041929731","fromNode":"89d72dc2215ab008","fromSide":"bottom","toNode":"e9cd05fc6af29f8a","toSide":"top"},
		{"id":"d933f6618b8d2041","fromNode":"e9cd05fc6af29f8a","fromSide":"bottom","toNode":"68cece06e9e319d6","toSide":"top"},
		{"id":"449efbc82ed4c483","fromNode":"1ef53e8f3bdc0256","fromSide":"bottom","toNode":"e0524a6106f7e079","toSide":"top"},
		{"id":"dcb08f6e52922065","fromNode":"e0524a6106f7e079","fromSide":"bottom","toNode":"2e180debab21a253","toSide":"top"},
		{"id":"f673ff76e2b05500","fromNode":"c577a9d9df782ff6","fromSide":"bottom","toNode":"1ef53e8f3bdc0256","toSide":"top"}
	]
}