{
	"nodes":[
		{"id":"a11dc5446f7b1dc3","type":"text","text":"GPU端数据：\n\nAABB Buffer\nObjectID Buffer\ninstanceDrawdata：  \nDrawIndirectBuffer ： 理解为渲染指令即可，记录VAO Mat，count， 等信息\nBatchInfoBuffer： 记录每个Batch，预估数量，然后产生段，比如Batch1用mat0绘制mesh1，在offset0， Batch2 则在offset50.\n","x":-365,"y":-380,"width":640,"height":220},
		{"id":"62f7b9844a5ea2fc","type":"text","text":"CopyBufferRegion\n脏列表记录offset，\nCopyBufferRegion一次更新一小块，可以通过位移发起多次， 不会造成太大性能压力","x":-900,"y":-353,"width":250,"height":167},
		{"id":"a374f2578b10d9e4","type":"text","text":"CPU端数据\n持有全量数据\n每帧持有dirtylist","x":-1320,"y":-353,"width":310,"height":168},
		{"id":"1d43a1b28ff8de7e","type":"text","text":"```cpp\n// 3. 录制复制指令 (GPU Copy) \n// 此时 Upload Buffer 已经准备好了，我们需要告诉 GPU 怎么分发这些数据 \nfor (int i = 0; i < numDirty; ++i) \n{   int realID = dirtyIDs[i]; \n\tcmdList->CopyBufferRegion( gpuAllObjectBuffer.Get(), // 目标 \n\tBuffer realID * objSize, // 目标偏移：跳到第 realID 个位置 \n\tuploadBuffer.Get(), // 源 \n\tBuffer i * objSize, // 源偏移：取第 i 个紧凑数据 \n\t\tobjSize // 复制大小：1个单位 \n);\n}\n```","x":-1037,"y":-840,"width":914,"height":320},
		{"id":"6fa4f69d2bc749e4","type":"text","text":"GPU Culling：\n发起一个cs，计算所有当前的AABBbuffer中的值。\n进行剔除，这个很简单，\n判断剔除是否成功， 如果在视锥内，进行下一步操作。\n拿到当前的Obj对应的indirectdraw ID，count++\n拿到当前Obj对应的instanceDrawdata起始位置，然后在他后面count位置记录当前ID，count代表已经填了几个了。\n至此，\ninstanceDrawdata更新了， Shader知道我这个batch从哪里开始绘制，绘制几个，用什么mesh和mat绘制。\n后面直接用DrawIndirect发起即可，","x":-600,"y":240,"width":430,"height":380},
		{"id":"583497fab7f84c0f","type":"text","text":"```cpp\n// 一次性 Dispatch(TotalObjectCount, 1, 1)\n\nvoid CSMain(uint3 id : SV_DispatchThreadID) {\n    uint objectID = id.x;\n    if (objectID >= TotalObjectCount) return;\n\n    // 1. 查身份：我是哪个 Batch 的？\n    ObjectData obj = AllObjectBuffer[objectID];\n    uint myBatchID = obj.batchID;\n\n    // 2. 查视锥：可见吗？\n    if (IsVisible(WorldBoundsBuffer[objectID])) {\n        \n        // 3. 关键：只更新我自己 Batch 的计数器！\n        // 注意：这里我们索引的是 IndirectArgs[myBatchID]\n        uint localIndex;\n        InterlockedAdd(IndirectArgs[myBatchID].instanceCount, 1, localIndex);\n\n        // 4. 关键：写到我自己 Batch 的地盘里！\n        // 查表得知 Batch 3 的地盘从 500 开始\n        uint globalOffset = BatchInfoBuffer[myBatchID].outputOffset;\n        \n        // 最终位置 = 地盘起点 + 我是本组第几个\n        VisibleInstanceIndexBuffer[globalOffset + localIndex] = objectID;\n    }\n}\n```\n\n\n\n\n\n\n","x":-1700,"y":60,"width":760,"height":681},
		{"id":"d951dc136791f436","type":"text","text":"CPU端需要扫Batch，预先有Batch相关信息才能喂给GPU","x":-330,"y":-80,"width":570,"height":140},
		{"id":"5145953838fe2c27","type":"text","text":"typedef struct D3D12_DRAW_INDEXED_ARGUMENTS {\n    UINT IndexCountPerInstance;\n    UINT InstanceCount;\n    UINT StartIndexLocation;\n    INT  BaseVertexLocation;\n    UINT StartInstanceLocation;\n} D3D12_DRAW_INDEXED_ARGUMENTS\n\n这个部分， 和之前的区别在于 Vertex也需要一个dabuffe， 然后记录位移。\n原则上我们不改变rootsignature， 一个sig绘制所有， 里面有多条IndirectDrawArgs， 来指向不同的mesh和材质，\n这个地方应该只能支持比如不透明渲染吧？ 半透明渲染的逻辑又不一样？\n半透明渲染涉及到很多的 pso切换","x":0,"y":240,"width":764,"height":400},
		{"id":"85c3b22a6a84ef03","type":"text","text":"**完全正确！你已经把现代 3A 引擎渲染管线的“最终形态”拼凑出来了。**\n\n你的总结非常精准，这就是目前工业界（比如 DOOM Eternal, 刺客信条, 虚幻 5 Nanite）所采用的标准架构：**Bindless + UberShader + GPU Driven + MegaBuffer**。\n\n为了确保你的理解没有偏差，我稍微修正一个概念，然后我们就定下这个方案。\n\n### 1. 修正一个小细节：DrawArgs 的数量与 PSO\n\n你提到：“_IndirectDrawArgs的数量等于PSO的数量_”。 更准确的说法是：**ExecuteIndirect 的调用次数（Draw Call 数量）等于 PSO 的数量。**\n\n但在内存里：\n\n- **IndirectArgsBuffer** 可以是**一个**巨大的 Buffer，里面存了 1000 个 `DrawArgs` 结构体。\n- **PSO 分组** 只是逻辑上的划分。\n\n**运行时流程是这样的：** 假设你有 1000 个 Batch，其中 0~~800 是不透明 UberShader，801~~1000 是特殊的 WaterShader。\n\n1. **Compute Shader**：一次性算出这 1000 个 Batch 的 `InstanceCount`（它不关心 PSO，只关心数学剔除）。\n2. **渲染循环 (CPU)**：\n    - **Pass 1 (Opaque)**:\n        - `SetPipelineState(UberPSO)`\n        - `ExecuteIndirect(..., Count = 800, Offset = 0)` <-- 画前 800 个\n    - **Pass 2 (Water)**:\n        - `SetPipelineState(WaterPSO)`\n        - `ExecuteIndirect(..., Count = 200, Offset = 800 * sizeof(Args))` <-- 画后 200 个\n\n所以，数据都在一起，只是我们**分段**去执行它。\n\n---\n\n### 2. 你的“神装”配置清单\n\n你刚才提到的那几个术语，正是支撑这套架构的四大支柱。确认一下它们的职责：\n\n|组件|职责|核心作用|\n|:--|:--|:--|\n|**Mega Mesh Buffer** (Global VB/IB)|把所有模型顶点拼在一起|消除 `SetVertexBuffers` 开销，允许通过 `BaseVertexLocation` 随意切换模型。|\n|**Raw Material Buffer** (StructuredBuffer)|存所有材质参数 (Color, Roughness, TextureID)|消除 `CreateConstantBuffer` 和 `SetGraphicsRootDescriptorTable` 的开销。VS/PS 通过 `InstanceID -> MaterialID` 自己去查。|\n|**Bindless Textures** (Descriptor Heap)|把所有贴图塞进一个大数组 `Texture2D g_Tex[]`|消除 `SetShaderResource` 开销。Shader 里直接写 `g_Tex[mat.diffuseTexID].Sample(...)`。|\n|**Uber Shader**|一个巨大的 Shader 处理所有不透明情况|消除 `SetPipelineState` 开销。用分支 (`if(hasNormalMap)`) 代替切换 Shader。|\n\n---\n\n### 3. 半透明 (Transparency) 的策略\n\n既然你已经理顺了，对于半透明，我建议分阶段实施：\n\n**阶段一：混合管线 (Hybrid Pipeline) —— 推荐**\n\n- **不透明 (90% 物体)**：走刚才这套 GPU Driven 无敌管线。\n- **半透明 (10% 物体)**：\n    - GPU 剔除完之后，把可见的 ID **Readback** 回 CPU（或者直接由 CPU 做简单的视锥剔除）。\n    - CPU 拿着这些 ID，计算距离，`std::sort` 排序。\n    - 使用传统的 `DrawIndexed` 一个个画，或者组几个小的 Instance Batch 画。\n- **理由**：半透明物体通常需要特殊的 Shader 变体多（玻璃、水、粒子、全息），且数量少，CPU 处理完全没瓶颈。\n\n**阶段二：纯 GPU (GPU Sort) —— 以后再说**\n\n- 只有当你做粒子系统（百万级半透明粒子）时，才需要上 GPU Bitonic Sort。对于普通场景 Mesh，阶段一足够用到下个世纪。\n\n---\n\n### 总结：你的 Action Plan\n\n基于这个架构，你接下来的开发顺序非常清晰：\n\n1. **数据层 (CPU)**：\n    - 实现 **GlobalVertexBuffer** 管理器（能把 obj 合并进去，记录 offset）。\n    - 实现 **MaterialSystem**（把材质参数打包进 UploadBuffer）。\n2. **GPU Culling (Compute)**：\n    - 写最简单的 Shader，输入 `AllObjects`，输出 `IndirectArgs` 里的 `InstanceCount`。\n    - **先不管 Draw，先用 Readback 打印 `InstanceCount` 看看对不对。**\n3. **渲染层 (Draw)**：\n    - 创建一个最简单的 **Uber Shader** (只输出颜色)。\n    - 使用 `ExecuteIndirect` 跑通流程。\n\n这套架构做出来，你的引擎在性能的“起跑线”上就已经领先市面上 80% 的教程引擎了。开搞！","x":1116,"y":13,"width":1204,"height":2047}
	],
	"edges":[
		{"id":"c610c1bee733afc2","fromNode":"d951dc136791f436","fromSide":"bottom","toNode":"6fa4f69d2bc749e4","toSide":"top"},
		{"id":"96b425e7d3c862a8","fromNode":"6fa4f69d2bc749e4","fromSide":"left","toNode":"583497fab7f84c0f","toSide":"right"},
		{"id":"6a581f58c14eb6fa","fromNode":"a374f2578b10d9e4","fromSide":"right","toNode":"62f7b9844a5ea2fc","toSide":"left"},
		{"id":"b04a9e4833087c29","fromNode":"62f7b9844a5ea2fc","fromSide":"right","toNode":"a11dc5446f7b1dc3","toSide":"left"},
		{"id":"3ef0179e0c354381","fromNode":"62f7b9844a5ea2fc","fromSide":"top","toNode":"1d43a1b28ff8de7e","toSide":"bottom"},
		{"id":"b27ab2014d8b4f66","fromNode":"a11dc5446f7b1dc3","fromSide":"bottom","toNode":"d951dc136791f436","toSide":"top"}
	]
}