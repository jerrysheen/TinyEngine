{
	"nodes":[
		{"id":"de1e802af1329936","type":"text","text":"ResourceManager\n","x":-323,"y":-174,"width":250,"height":60},
		{"id":"05b358a92fbdc354","type":"text","text":"LoadTask\n{\n\n\n}\n这玩意是个什么？\nLoadTask相当于是一个Resource的请求信息，包含这个Resource加载的所有信息， 包括它的ID， dependency，vector callbacks\n以及它自己的finalize？ 我姑且理解为是Resources::OnloadComplete","x":-500,"y":-60,"width":520,"height":240},
		{"id":"6636b11aa6c46df1","type":"text","text":"是不是只给LoadAsync？ 就是LoadAsync和 LoadSync怎么一起做","x":80,"y":0,"width":250,"height":160},
		{"id":"7f96e7adbfc4b808","type":"text","text":"MainThread:\n当发起ResourcesManager::LoadAsync的时候，外部需要一个回调， 比如这个handle加载完之后，meshrenderer里面做一些事情， 这个被称为callback，一个Resources会记录多个这种callback，因为它被多个meshrenderer请求。\n\n","x":-803,"y":340,"width":480,"height":360},
		{"id":"195c69a972cdf50a","type":"text","text":"WorkThread\n\n拿出一个Task， 最后返回一个LoadResult\nLoadResult中包含\nparent tasks\n和当前的dependency\n和加载完之后的Res， 这个事情在work线程做完后，\n返回一个LoadResult","x":-1658,"y":380,"width":440,"height":280},
		{"id":"856ebb397f9ac6f6","type":"text","text":"LoadTask：\nAssetID\nvector functioncallbacks\ndependencyList","x":-2130,"y":57,"width":250,"height":247},
		{"id":"b3c691c90708f7db","type":"text","text":"LoadResult\nLoadTask* parentTask;\nDependency\nResources* res;","x":-1658,"y":57,"width":250,"height":247},
		{"id":"7ed3b5694f3bb359","type":"text","text":"MainThread\n\nResourceManager::LoadAsyncLoadAssetAsync(AssetID assetID, std::function<void()> cb = nullptr, LoadTask* parent =\n  nullptr)\n检查资源是否已经finalize() 如果结束了就马上执行callback\n检查资源是否已经loaded，如果loaded了就说明还没finalized\n\n都没有的话说明资源还在加载过程中或者完全没加载，就发起Task* ，将这个callback加入task中，然后发到work线程\n\n==如果有parent，则要把parent的tryfinalized 和 dependency-- 打包成一个callbacks推进 task的callbacks里面==，\n\n","x":-2520,"y":380,"width":540,"height":360},
		{"id":"47b8a92547443d16","type":"text","text":"MainThread：\n\n拿到Loadresult，\nLoadAsync dependency（id, callbakcs）\n\nTryFinalize（）:【重点】 主要要理解这个资源什么时候加载完成->  首先看他的dependency是否为0，为0就加载完了， 不为0就return，\n\n如果为0了，那么看这个资源的task->state是否为loaded，如果是finalize，就说明执行完了，直接return\n\n如果是loaded了，那么就resourceMap id 设置为resource\n然后执行这个资源的所有callback\n将资源类型改为 finalized\n调resource -> onloadComplte\n\n父task的Tryfinalized在这个task的callbacks里面","x":-1980,"y":780,"width":450,"height":480},
		{"id":"babafa6d0801f96d","type":"text","text":" Runtime\\Resources\\ResourceManager.h 示例片段\n\n  // 仅示意：可以放在 ResourceManager 类里或前面\n  enum class LoadState\n  {\n      None,\n      Queued,\n      Loaded,\n      Finalized\n  };\n\n  struct LoadTask\n  {\n      AssetID id;\n      AssetType type = AssetType::Default;\n      std::string path;\n      Resource* resource = nullptr;\n      std::vector<IResourceLoader::LoadDependency> deps;\n      std::function<void()> finalize;\n      std::vector<std::function<void()>> callbacks;\n      int pendingDeps = 0; // 主线程改即可\n      LoadState state = LoadState::None;\n  };\n\n  class ResourceManager\n  {\n  public:\n      template<typename T>\n      ResourceHandle<T> LoadAssetAsync(AssetID assetID, std::function<void()> cb = nullptr, LoadTask* parent = nullptr)\n      {\n          LoadTask* task = GetOrCreateTask(assetID, AssetTypeTraits<T>::Type);\n\n          if (cb != nullptr)\n          {\n              task->callbacks.push_back(cb);\n          }\n\n          if (parent != nullptr)\n          {\n              parent->pendingDeps++;\n              // 依赖完成时通知父任务\n              task->callbacks.push_back([this, parent]()\n              {\n                  parent->pendingDeps--;\n                  TryFinalize(parent);\n              });\n          }\n\n          if (task->state == LoadState::None)\n          {\n              task->state = LoadState::Queued;\n              m_WorkThreadQueue.TryPush(task);\n          }\n\n          return ResourceHandle<T>(assetID);\n      }\n\n      void Update();\n\n  private:\n      LoadTask* GetOrCreateTask(AssetID id, AssetType type);\n      void TryFinalize(LoadTask* task);\n\n      ThreadSafeQueue<LoadTask*> m_WorkThreadQueue;\n      ThreadSafeQueue<LoadTask*> m_MainThreadCompleteQueue;\n      std::unordered_map<AssetID, LoadTask*> m_TaskMap;\n\n      // 现有成员：mResourceCache, m_Loaders, m_MainThreadQueue 等\n  };\n\n  Runtime\\Resources\\ResourceManager.cpp 示例片段\n\n  LoadTask* ResourceManager::GetOrCreateTask(AssetID id, AssetType type)\n  {\n      auto it = m_TaskMap.find(id);\n      if (it != m_TaskMap.end())\n      {\n          return it->second;\n      }\n\n      LoadTask* task = new LoadTask();\n      task->id = id;\n      task->type = type;\n      task->path = AssetRegistry::GetInstance()->GetAssetPath(id);\n\n      m_TaskMap[id] = task;\n      return task;\n  }\n\n  void ResourceManager::WorkThreadLoad()\n  {\n      while (isRuning || m_WorkThreadQueue.size() > 0)\n      {\n          LoadTask* task = nullptr;\n          m_WorkThreadQueue.WaitAndPop(task);\n\n          if (task == nullptr) continue;\n\n          IResourceLoader* loader = m_Loaders[task->type];\n          IResourceLoader::LoadResult result = loader->LoadWithResult(task->path);\n\n          task->resource = result.resource;\n          task->deps = std::move(result.dependencies);\n          task->finalize = std::move(result.finalize);\n          task->state = LoadState::Loaded;\n\n          m_MainThreadCompleteQueue.TryPush(task);\n      }\n  }\n\n  void ResourceManager::Update()\n  {\n      // 处理 worker 完成事件\n      LoadTask* task = nullptr;\n      while (m_MainThreadCompleteQueue.TryPop(task))\n      {\n          for (auto& dep : task->deps)\n          {\n              // 依赖任务在主线程统一登记\n              switch (dep.type)\n              {\n              case AssetType::Texture2D:\n                  LoadAssetAsync<Texture>(dep.id, nullptr, task);\n                  break;\n              case AssetType::Mesh:\n                  LoadAssetAsync<Mesh>(dep.id, nullptr, task);\n                  break;\n              default:\n                  break;\n              }\n          }\n\n          TryFinalize(task);\n      }\n\n      // 保留你原来的主线程队列处理\n      while (m_MainThreadQueue.size() > 0)\n      {\n          std::function<void()> lambda;\n          bool hasWork = m_MainThreadQueue.TryPop(lambda);\n          if (hasWork) lambda();\n      }\n  }\n\n  void ResourceManager::TryFinalize(LoadTask* task)\n  {\n      if (task == nullptr) return;\n      if (task->state != LoadState::Loaded) return;\n      if (task->pendingDeps > 0) return;\n\n      // 主线程 finalize\n      mResourceCache[task->id] = task->resource;\n\n      if (task->finalize)\n      {\n          task->finalize();\n      }\n\n      if (task->resource)\n      {\n          task->resource->OnLoadComplete();\n      }\n\n      for (auto& cb : task->callbacks)\n      {\n          if (cb) cb();\n      }\n      task->callbacks.clear();\n\n      task->state = LoadState::Finalized;\n  }\n\n  Runtime\\Serialization\\MeshLoader.h 示例片段\n\n  class MeshLoader : public IResourceLoader\n  {\n  public:\n      virtual ~MeshLoader() = default;\n\n      virtual Resource* Load(const std::string& relativePath) override\n      {\n          std::string path = PathSettings::ResolveAssetPath(relativePath);\n          std::ifstream in(path, std::ios::binary);\n          in.seekg(sizeof(AssetHeader));\n\n          Mesh* mesh = new Mesh();\n          mesh->SetAssetCreateMethod(AssetCreateMethod::Serialization);","x":-3790,"y":880,"width":1540,"height":4720}
	],
	"edges":[
		{"id":"c70cc09cc3ac5005","fromNode":"05b358a92fbdc354","fromSide":"bottom","toNode":"7f96e7adbfc4b808","toSide":"top"},
		{"id":"95925eaa5379b18b","fromNode":"7ed3b5694f3bb359","fromSide":"top","toNode":"195c69a972cdf50a","toSide":"top"},
		{"id":"724a969a16ff95cc","fromNode":"195c69a972cdf50a","fromSide":"bottom","toNode":"47b8a92547443d16","toSide":"right"}
	]
}