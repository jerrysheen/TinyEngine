# TinyEngine å¯æ’æ‹”æ¨¡å¼æ€§èƒ½æ¯”è¾ƒè®¾è®¡æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

**ç‰ˆæœ¬**: 1.0  
**æ—¥æœŸ**: 2025-11-10  
**ä½œè€…**: TinyEngine Team  
**ç›®æ ‡**: è®¾è®¡ä¸€å¥—å¯æ’æ‹”çš„æ¸²æŸ“ä¼˜åŒ–ç³»ç»Ÿï¼Œæ”¯æŒè¿è¡Œæ—¶åˆ‡æ¢å’Œæ€§èƒ½å¯¹æ¯”

---

## ğŸ¯ è®¾è®¡ç›®æ ‡

### **æ ¸å¿ƒç†å¿µ**
é‡‡ç”¨**ç­–ç•¥æ¨¡å¼ + ç®¡çº¿åŒ–è®¾è®¡**ï¼Œå°†æ¸²æŸ“ä¼˜åŒ–åšæˆå¯æ’æ‹”çš„æ¨¡å—ï¼Œæ”¯æŒï¼š

1. âœ… **è¿è¡Œæ—¶åˆ‡æ¢** - æ— éœ€é‡æ–°ç¼–è¯‘ï¼Œå®æ—¶å¼€å…³ä¼˜åŒ–
2. âœ… **æ€§èƒ½å¯¹æ¯”** - åŒä¸€åœºæ™¯ä¸‹æµ‹è¯•ä¸åŒä¼˜åŒ–ç»„åˆçš„æ•ˆæœ
3. âœ… **é›¶ä¾µå…¥** - ä¸ç ´åç°æœ‰ä»£ç ç»“æ„ï¼Œæ˜“äºé›†æˆ
4. âœ… **æ˜“æ‰©å±•** - æ–°å¢ä¼˜åŒ–ç­–ç•¥åªéœ€å®ç°æ¥å£
5. âœ… **ç‹¬ç«‹æµ‹è¯•** - æ¯ä¸ªç­–ç•¥å¯ä»¥å•ç‹¬å¼€å‘å’ŒéªŒè¯

### **ä¼˜åŒ–æ¨¡å—**
- **Culling å‰”é™¤æ¨¡å—** - 3ç§ç­–ç•¥ï¼ˆæ— å‰”é™¤ã€å•çº¿ç¨‹ã€å¤šçº¿ç¨‹ï¼‰
- **Batching æ‰¹å¤„ç†æ¨¡å—** - 2ç§ç­–ç•¥ï¼ˆæ— æ‰¹å¤„ç†ã€SRP Batchï¼‰
- **Instancing å®ä¾‹åŒ–æ¨¡å—** - å¯é€‰å¼€å…³

---

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### **æ•°æ®æµè®¾è®¡**

```
åœºæ™¯å¯¹è±¡åˆ—è¡¨ (GameObject[])
         â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Culling ç­–ç•¥é€‰æ‹©   â”‚ â† æ ¹æ® RenderSettings
    â”‚  â”œâ”€ NoCulling       â”‚    é€‰æ‹©å…·ä½“ç­–ç•¥
    â”‚  â”œâ”€ Frustum (å•çº¿ç¨‹)â”‚
    â”‚  â””â”€ Frustum (å¤šçº¿ç¨‹)â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
å¯è§ç‰©ä½“åˆ—è¡¨ (VisibleItem[])
         â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Batching ç­–ç•¥é€‰æ‹©  â”‚ â† æ ¹æ® RenderSettings
    â”‚  â”œâ”€ NoBatching      â”‚    é€‰æ‹©å…·ä½“ç­–ç•¥
    â”‚  â””â”€ SRPBatching     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
æ¸²æŸ“æ‰¹æ¬¡åˆ—è¡¨ (RenderBatch[])
         â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Renderer æ¸²æŸ“      â”‚
    â”‚  â”œâ”€ DrawIndexed     â”‚ â† å•ç‰©ä½“æ¸²æŸ“
    â”‚  â””â”€ DrawInstanced   â”‚ â† GPU Instancing
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
    DrawCall æäº¤åˆ° GPU
```

### **ç­–ç•¥æ¨¡å¼æ ¸å¿ƒ**

```cpp
// ç»Ÿä¸€æ¥å£
interface IStrategy {
    execute(input) -> output
    getStats() -> Stats
}

// å…·ä½“ç­–ç•¥
class Strategy1 implements IStrategy { ... }
class Strategy2 implements IStrategy { ... }

// ç­–ç•¥ç®¡ç†å™¨
class Manager {
    selectStrategy(settings) -> IStrategy
    execute(input) {
        strategy = selectStrategy()
        output = strategy.execute(input)
        recordStats(strategy.getStats())
        return output
    }
}
```

---

## ğŸ“¦ æ¨¡å—1ï¼šCulling å‰”é™¤ç³»ç»Ÿ

### **1.1 ç­–ç•¥æ¥å£å®šä¹‰**

```cpp
// Runtime/Renderer/Culling.h
namespace EngineCore
{
    /// <summary>
    /// å‰”é™¤ç»Ÿè®¡æ•°æ®
    /// </summary>
    struct CullingStats
    {
        int totalObjects = 0;       // æ€»å¯¹è±¡æ•°
        int visibleObjects = 0;     // å¯è§å¯¹è±¡æ•°
        int culledObjects = 0;      // è¢«å‰”é™¤å¯¹è±¡æ•°
        float cullingTime = 0.0f;   // å‰”é™¤è€—æ—¶ï¼ˆmsï¼‰
        std::string strategyName;   // ç­–ç•¥åç§°
    };
    
    /// <summary>
    /// å‰”é™¤ç­–ç•¥æ¥å£ - ç­–ç•¥æ¨¡å¼åŸºç±»
    /// </summary>
    class ICullingStrategy
    {
    public:
        virtual ~ICullingStrategy() = default;
        
        /// <summary>
        /// æ‰§è¡Œå‰”é™¤
        /// </summary>
        /// <param name="cam">ç›¸æœº</param>
        /// <param name="allObjects">åœºæ™¯ä¸­æ‰€æœ‰å¯¹è±¡</param>
        /// <param name="outContext">è¾“å‡ºçš„æ¸²æŸ“ä¸Šä¸‹æ–‡ï¼ˆå¡«å……å¯è§ç‰©ä½“ï¼‰</param>
        virtual void Execute(Camera* cam, 
                            const std::vector<GameObject*>& allObjects,
                            RenderContext& outContext) = 0;
        
        /// <summary>
        /// è·å–æœ¬æ¬¡å‰”é™¤çš„ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        virtual CullingStats GetStats() const = 0;
        
        /// <summary>
        /// è·å–ç­–ç•¥åç§°
        /// </summary>
        virtual const char* GetName() const = 0;
    };
}
```

### **1.2 ç­–ç•¥å®ç°ï¼šæ— å‰”é™¤ï¼ˆåŸºå‡†æµ‹è¯•ï¼‰**

```cpp
/// <summary>
/// ç­–ç•¥1ï¼šæ— å‰”é™¤ - æ‰€æœ‰å¯¹è±¡éƒ½æ¸²æŸ“
/// ç”¨é€”ï¼šæ€§èƒ½åŸºå‡†æµ‹è¯•ï¼Œå¯¹æ¯”ä¼˜åŒ–æ•ˆæœ
/// </summary>
class NoCullingStrategy : public ICullingStrategy
{
public:
    void Execute(Camera* cam, 
                const std::vector<GameObject*>& allObjects,
                RenderContext& outContext) override
    {
        auto startTime = std::chrono::high_resolution_clock::now();
        
        mStats.totalObjects = 0;
        mStats.visibleObjects = 0;
        
        // ç›´æ¥æŠŠæ‰€æœ‰å¯¹è±¡åŠ å…¥å¯è§åˆ—è¡¨ï¼ˆä¸åšä»»ä½•æµ‹è¯•ï¼‰
        for (auto* go : allObjects)
        {
            auto* meshRenderer = go->GetComponent<MeshRenderer>();
            auto* meshFilter = go->GetComponent<MeshFilter>();
            
            if (!meshRenderer || !meshFilter || !go->IsActive())
                continue;
                
            mStats.totalObjects++;
            
            // åˆ›å»ºå¯è§ç‰©ä½“é¡¹
            auto* item = outContext.GetAvalileVisibleItem();
            item->mat = meshRenderer->mMatHandle.Get();
            item->model = meshFilter->mMeshHandle.Get();
            item->worldMatrix = go->GetComponent<Transform>()->GetWorldMatrix();
            
            outContext.cameraVisibleItems.push_back(item);
            mStats.visibleObjects++;
        }
        
        mStats.culledObjects = 0;  // æ— å‰”é™¤
        
        auto endTime = std::chrono::high_resolution_clock::now();
        mStats.cullingTime = std::chrono::duration<float, std::milli>(
            endTime - startTime).count();
        mStats.strategyName = GetName();
    }
    
    CullingStats GetStats() const override { return mStats; }
    const char* GetName() const override { return "No Culling"; }
    
private:
    CullingStats mStats;
};
```

### **1.3 ç­–ç•¥å®ç°ï¼šå•çº¿ç¨‹Frustumå‰”é™¤**

```cpp
/// <summary>
/// ç­–ç•¥2ï¼šå•çº¿ç¨‹Frustumå‰”é™¤
/// ç”¨é€”ï¼šåŸºç¡€çš„è§†é”¥å‰”é™¤ï¼Œå•çº¿ç¨‹å®ç°
/// </summary>
class FrustumCullingStrategy : public ICullingStrategy
{
public:
    void Execute(Camera* cam, 
                const std::vector<GameObject*>& allObjects,
                RenderContext& outContext) override
    {
        auto startTime = std::chrono::high_resolution_clock::now();
        
        // æå–ç›¸æœºFrustum
        Frustum frustum = cam->GetFrustum();
        
        mStats.totalObjects = 0;
        mStats.visibleObjects = 0;
        mStats.culledObjects = 0;
        
        // å•çº¿ç¨‹éå†æ‰€æœ‰å¯¹è±¡
        for (auto* go : allObjects)
        {
            auto* meshRenderer = go->GetComponent<MeshRenderer>();
            auto* meshFilter = go->GetComponent<MeshFilter>();
            
            if (!meshRenderer || !meshFilter || !go->IsActive())
                continue;
                
            mStats.totalObjects++;
            
            // Frustumå‰”é™¤æµ‹è¯•
            AABB worldAABB = meshRenderer->GetWorldAABB();
            if (!frustum.IntersectsAABB(worldAABB))
            {
                mStats.culledObjects++;
                continue;  // è¢«å‰”é™¤ï¼Œä¸æ¸²æŸ“
            }
            
            // å¯è§ï¼ŒåŠ å…¥åˆ—è¡¨
            auto* item = outContext.GetAvalileVisibleItem();
            item->mat = meshRenderer->mMatHandle.Get();
            item->model = meshFilter->mMeshHandle.Get();
            item->worldMatrix = go->GetComponent<Transform>()->GetWorldMatrix();
            
            outContext.cameraVisibleItems.push_back(item);
            mStats.visibleObjects++;
        }
        
        auto endTime = std::chrono::high_resolution_clock::now();
        mStats.cullingTime = std::chrono::duration<float, std::milli>(
            endTime - startTime).count();
        mStats.strategyName = GetName();
    }
    
    CullingStats GetStats() const override { return mStats; }
    const char* GetName() const override { return "Frustum Culling (Single-thread)"; }
    
private:
    CullingStats mStats;
};
```

### **1.4 ç­–ç•¥å®ç°ï¼šå¤šçº¿ç¨‹Frustumå‰”é™¤**

```cpp
/// <summary>
/// ç­–ç•¥3ï¼šå¤šçº¿ç¨‹Frustumå‰”é™¤
/// ç”¨é€”ï¼šå¹¶è¡ŒåŒ–å‰”é™¤ï¼Œæå‡å¤§åœºæ™¯æ€§èƒ½
/// </summary>
class MultithreadCullingStrategy : public ICullingStrategy
{
public:
    void Execute(Camera* cam, 
                const std::vector<GameObject*>& allObjects,
                RenderContext& outContext) override
    {
        auto startTime = std::chrono::high_resolution_clock::now();
        
        Frustum frustum = cam->GetFrustum();
        
        // è·å–çº¿ç¨‹æ•°é…ç½®
        int threadCount = RenderSettings::GetInstance()->cullingThreadCount;
        int objectsPerThread = (allObjects.size() + threadCount - 1) / threadCount;
        
        // æ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹çš„ç»“æœç¼“å­˜ï¼ˆé¿å…é”ç«äº‰ï¼‰
        struct ThreadResult
        {
            std::vector<VisibleItem*> items;
            int totalCount = 0;
            int visibleCount = 0;
            int culledCount = 0;
        };
        std::vector<ThreadResult> threadResults(threadCount);
        
        // å¹¶è¡Œæ‰§è¡Œå‰”é™¤
        std::vector<std::future<void>> futures;
        for (int i = 0; i < threadCount; ++i)
        {
            futures.push_back(std::async(std::launch::async, 
                [&, threadIndex = i]()
            {
                int startIdx = threadIndex * objectsPerThread;
                int endIdx = std::min(startIdx + objectsPerThread, 
                                     (int)allObjects.size());
                
                auto& result = threadResults[threadIndex];
                
                for (int j = startIdx; j < endIdx; ++j)
                {
                    auto* go = allObjects[j];
                    auto* meshRenderer = go->GetComponent<MeshRenderer>();
                    auto* meshFilter = go->GetComponent<MeshFilter>();
                    
                    if (!meshRenderer || !meshFilter || !go->IsActive())
                        continue;
                    
                    result.totalCount++;
                    
                    // Frustumæµ‹è¯•
                    AABB worldAABB = meshRenderer->GetWorldAABB();
                    if (!frustum.IntersectsAABB(worldAABB))
                    {
                        result.culledCount++;
                        continue;
                    }
                    
                    // å¯è§ï¼Œæ·»åŠ åˆ°çº¿ç¨‹æœ¬åœ°ç¼“å­˜
                    auto* item = outContext.GetAvalileVisibleItem();
                    item->mat = meshRenderer->mMatHandle.Get();
                    item->model = meshFilter->mMeshHandle.Get();
                    item->worldMatrix = go->GetComponent<Transform>()->GetWorldMatrix();
                    
                    result.items.push_back(item);
                    result.visibleCount++;
                }
            }));
        }
        
        // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for (auto& future : futures)
        {
            future.wait();
        }
        
        // ä¸»çº¿ç¨‹åˆå¹¶ç»“æœ
        mStats.totalObjects = 0;
        mStats.visibleObjects = 0;
        mStats.culledObjects = 0;
        
        for (auto& result : threadResults)
        {
            // åˆå¹¶å¯è§ç‰©ä½“åˆ—è¡¨
            outContext.cameraVisibleItems.insert(
                outContext.cameraVisibleItems.end(),
                result.items.begin(),
                result.items.end());
            
            // åˆå¹¶ç»Ÿè®¡æ•°æ®
            mStats.totalObjects += result.totalCount;
            mStats.visibleObjects += result.visibleCount;
            mStats.culledObjects += result.culledCount;
        }
        
        auto endTime = std::chrono::high_resolution_clock::now();
        mStats.cullingTime = std::chrono::duration<float, std::milli>(
            endTime - startTime).count();
        mStats.strategyName = GetName();
    }
    
    CullingStats GetStats() const override { return mStats; }
    const char* GetName() const override { return "Frustum Culling (Multi-thread)"; }
    
private:
    CullingStats mStats;
};
```

### **1.5 ç­–ç•¥ç®¡ç†å™¨**

```cpp
/// <summary>
/// Cullingç®¡ç†å™¨ - ç»Ÿä¸€å…¥å£ï¼Œæ ¹æ®è®¾ç½®é€‰æ‹©ç­–ç•¥
/// </summary>
class Culling
{
public:
    /// <summary>
    /// æ‰§è¡Œå‰”é™¤ï¼ˆè‡ªåŠ¨é€‰æ‹©ç­–ç•¥ï¼‰
    /// </summary>
    static void Run(Camera* cam, RenderContext& context)
    {
        auto* settings = RenderSettings::GetInstance();
        auto* scene = SceneManager::GetInstance()->GetCurrentScene();
        
        // æ ¹æ®è®¾ç½®é€‰æ‹©å‰”é™¤ç­–ç•¥
        ICullingStrategy* strategy = SelectStrategy(settings);
        
        // é‡ç½®ä¸Šä¸‹æ–‡
        context.Reset();
        context.camera = cam;
        
        // æ‰§è¡Œå‰”é™¤
        strategy->Execute(cam, scene->allObjList, context);
        
        // è®°å½•ç»Ÿè®¡ä¿¡æ¯
        s_CurrentStats = strategy->GetStats();
        RenderStatsManager::GetInstance()->RecordCullingStats(s_CurrentStats);
    }
    
    /// <summary>
    /// è·å–æœ€è¿‘ä¸€æ¬¡å‰”é™¤çš„ç»Ÿè®¡ä¿¡æ¯
    /// </summary>
    static const CullingStats& GetStats() { return s_CurrentStats; }
    
private:
    /// <summary>
    /// æ ¹æ®è®¾ç½®é€‰æ‹©ç­–ç•¥
    /// </summary>
    static ICullingStrategy* SelectStrategy(RenderSettings* settings)
    {
        if (!settings->enableFrustumCulling)
        {
            // æ— å‰”é™¤
            return &s_NoCullingStrategy;
        }
        else if (settings->enableMultithreadCulling)
        {
            // å¤šçº¿ç¨‹å‰”é™¤
            return &s_MultithreadStrategy;
        }
        else
        {
            // å•çº¿ç¨‹å‰”é™¤
            return &s_FrustumStrategy;
        }
    }
    
private:
    // ç­–ç•¥å®ä¾‹ï¼ˆå•ä¾‹æ¨¡å¼ï¼Œé¿å…é‡å¤åˆ›å»ºï¼‰
    static NoCullingStrategy s_NoCullingStrategy;
    static FrustumCullingStrategy s_FrustumStrategy;
    static MultithreadCullingStrategy s_MultithreadStrategy;
    
    // å½“å‰ç»Ÿè®¡
    static CullingStats s_CurrentStats;
};

// é™æ€æˆå‘˜åˆå§‹åŒ–
NoCullingStrategy Culling::s_NoCullingStrategy;
FrustumCullingStrategy Culling::s_FrustumStrategy;
MultithreadCullingStrategy Culling::s_MultithreadStrategy;
CullingStats Culling::s_CurrentStats;
```

---

## ğŸ“¦ æ¨¡å—2ï¼šBatching æ‰¹å¤„ç†ç³»ç»Ÿ

### **2.1 æ•°æ®ç»“æ„**

```cpp
// Runtime/Renderer/RenderBatch.h
namespace EngineCore
{
    /// <summary>
    /// æ¸²æŸ“æ‰¹æ¬¡ - å°†ç›¸åŒæè´¨å’ŒMeshçš„ç‰©ä½“åˆå¹¶
    /// </summary>
    struct RenderBatch
    {
        const Shader* shader = nullptr;
        const Material* material = nullptr;
        const ModelData* mesh = nullptr;
        
        std::vector<Matrix4x4> worldMatrices;  // æ‰€æœ‰å®ä¾‹çš„ä¸–ç•ŒçŸ©é˜µ
        int instanceCount = 0;
        
        /// <summary>
        /// ç”Ÿæˆæ’åºé”®ï¼ˆç”¨äºæè´¨æ’åºï¼‰
        /// æ ¼å¼ï¼š[Shader(32bit)][Material(16bit)][Mesh(16bit)]
        /// </summary>
        uint64_t GetSortKey() const
        {
            uint64_t shaderKey = reinterpret_cast<uint64_t>(shader) >> 4;
            uint64_t matKey = reinterpret_cast<uint64_t>(material) >> 8;
            uint64_t meshKey = reinterpret_cast<uint64_t>(mesh) >> 12;
            
            return (shaderKey << 32) | (matKey << 16) | meshKey;
        }
        
        bool operator<(const RenderBatch& other) const
        {
            return GetSortKey() < other.GetSortKey();
        }
    };
    
    /// <summary>
    /// æ‰¹å¤„ç†ç»Ÿè®¡æ•°æ®
    /// </summary>
    struct BatchingStats
    {
        int originalDrawCalls = 0;   // åŸå§‹DrawCallæ•°ï¼ˆæ— æ‰¹å¤„ç†ï¼‰
        int batchCount = 0;           // æ‰¹æ¬¡æ•°ï¼ˆæ‰¹å¤„ç†åï¼‰
        float batchingRate = 0.0f;    // åˆæ‰¹ç‡ï¼ˆ0.0-1.0ï¼‰
        float batchingTime = 0.0f;    // æ‰¹å¤„ç†è€—æ—¶ï¼ˆmsï¼‰
        int materialSwitches = 0;     // æè´¨åˆ‡æ¢æ¬¡æ•°
        int shaderSwitches = 0;       // Shaderåˆ‡æ¢æ¬¡æ•°
        std::string strategyName;     // ç­–ç•¥åç§°
    };
}
```

### **2.2 ç­–ç•¥æ¥å£**

```cpp
/// <summary>
/// æ‰¹å¤„ç†ç­–ç•¥æ¥å£
/// </summary>
class IBatchingStrategy
{
public:
    virtual ~IBatchingStrategy() = default;
    
    /// <summary>
    /// æ„å»ºæ‰¹æ¬¡
    /// </summary>
    /// <param name="visibleItems">å¯è§ç‰©ä½“åˆ—è¡¨</param>
    /// <returns>æ¸²æŸ“æ‰¹æ¬¡åˆ—è¡¨</returns>
    virtual std::vector<RenderBatch> BuildBatches(
        const std::vector<VisibleItem*>& visibleItems) = 0;
    
    /// <summary>
    /// è·å–æ‰¹å¤„ç†ç»Ÿè®¡ä¿¡æ¯
    /// </summary>
    virtual BatchingStats GetStats() const = 0;
    
    /// <summary>
    /// è·å–ç­–ç•¥åç§°
    /// </summary>
    virtual const char* GetName() const = 0;
};
```

### **2.3 ç­–ç•¥å®ç°ï¼šæ— æ‰¹å¤„ç†**

```cpp
/// <summary>
/// ç­–ç•¥1ï¼šæ— æ‰¹å¤„ç† - æ¯ä¸ªç‰©ä½“ä¸€ä¸ªDrawCall
/// ç”¨é€”ï¼šæ€§èƒ½åŸºå‡†æµ‹è¯•
/// </summary>
class NoBatchingStrategy : public IBatchingStrategy
{
public:
    std::vector<RenderBatch> BuildBatches(
        const std::vector<VisibleItem*>& visibleItems) override
    {
        auto startTime = std::chrono::high_resolution_clock::now();
        
        // æ¯ä¸ªç‰©ä½“åˆ›å»ºä¸€ä¸ªç‹¬ç«‹æ‰¹æ¬¡
        std::vector<RenderBatch> batches;
        batches.reserve(visibleItems.size());
        
        for (auto* item : visibleItems)
        {
            RenderBatch batch;
            batch.shader = item->mat->GetShader();
            batch.material = item->mat;
            batch.mesh = item->model;
            batch.worldMatrices.push_back(item->worldMatrix);
            batch.instanceCount = 1;
            
            batches.push_back(batch);
        }
        
        // ç»Ÿè®¡
        mStats.originalDrawCalls = visibleItems.size();
        mStats.batchCount = batches.size();
        mStats.batchingRate = 0.0f;  // æ— åˆæ‰¹
        mStats.materialSwitches = batches.size();  // æ¯æ¬¡éƒ½åˆ‡æ¢
        mStats.shaderSwitches = batches.size();
        
        auto endTime = std::chrono::high_resolution_clock::now();
        mStats.batchingTime = std::chrono::duration<float, std::milli>(
            endTime - startTime).count();
        mStats.strategyName = GetName();
        
        return batches;
    }
    
    BatchingStats GetStats() const override { return mStats; }
    const char* GetName() const override { return "No Batching"; }
    
private:
    BatchingStats mStats;
};
```

### **2.4 ç­–ç•¥å®ç°ï¼šSRP Batch**

```cpp
/// <summary>
/// ç­–ç•¥2ï¼šSRP Batch - æ’åº + åˆå¹¶ç›¸åŒæè´¨çš„ç‰©ä½“
/// ç”¨é€”ï¼šå‡å°‘çŠ¶æ€åˆ‡æ¢ï¼Œæ”¯æŒGPU Instancing
/// </summary>
class SRPBatchingStrategy : public IBatchingStrategy
{
public:
    std::vector<RenderBatch> BuildBatches(
        const std::vector<VisibleItem*>& visibleItems) override
    {
        if (visibleItems.empty())
            return {};
        
        auto startTime = std::chrono::high_resolution_clock::now();
        
        // ============================================
        // æ­¥éª¤1ï¼šæ’åºï¼ˆShader > Material > Meshï¼‰
        // ============================================
        std::vector<VisibleItem*> sortedItems = visibleItems;
        std::sort(sortedItems.begin(), sortedItems.end(), 
            [](const VisibleItem* a, const VisibleItem* b)
        {
            // ä¼˜å…ˆçº§1ï¼šShaderï¼ˆåˆ‡æ¢Shaderæœ€æ˜‚è´µï¼‰
            if (a->mat->GetShader() != b->mat->GetShader())
                return a->mat->GetShader() < b->mat->GetShader();
            
            // ä¼˜å…ˆçº§2ï¼šMaterial
            if (a->mat != b->mat)
                return a->mat < b->mat;
            
            // ä¼˜å…ˆçº§3ï¼šMesh
            return a->model < b->model;
        });
        
        // ============================================
        // æ­¥éª¤2ï¼šåˆå¹¶ç›¸åŒæè´¨å’ŒMeshçš„ç‰©ä½“
        // ============================================
        std::vector<RenderBatch> batches;
        RenderBatch currentBatch;
        currentBatch.shader = sortedItems[0]->mat->GetShader();
        currentBatch.material = sortedItems[0]->mat;
        currentBatch.mesh = sortedItems[0]->model;
        currentBatch.worldMatrices.push_back(sortedItems[0]->worldMatrix);
        currentBatch.instanceCount = 1;
        
        const Shader* lastShader = currentBatch.shader;
        const Material* lastMaterial = currentBatch.material;
        
        mStats.shaderSwitches = 1;
        mStats.materialSwitches = 1;
        
        for (size_t i = 1; i < sortedItems.size(); ++i)
        {
            auto* item = sortedItems[i];
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆæ‰¹
            bool canBatch = (item->mat->GetShader() == currentBatch.shader &&
                            item->mat == currentBatch.material &&
                            item->model == currentBatch.mesh);
            
            if (canBatch)
            {
                // åˆå¹¶åˆ°å½“å‰æ‰¹æ¬¡
                currentBatch.worldMatrices.push_back(item->worldMatrix);
                currentBatch.instanceCount++;
            }
            else
            {
                // ä¿å­˜å½“å‰æ‰¹æ¬¡ï¼Œå¼€å¯æ–°æ‰¹æ¬¡
                batches.push_back(currentBatch);
                
                // ç»Ÿè®¡çŠ¶æ€åˆ‡æ¢
                if (item->mat->GetShader() != lastShader)
                {
                    mStats.shaderSwitches++;
                    lastShader = item->mat->GetShader();
                }
                if (item->mat != lastMaterial)
                {
                    mStats.materialSwitches++;
                    lastMaterial = item->mat;
                }
                
                // åˆ›å»ºæ–°æ‰¹æ¬¡
                currentBatch = RenderBatch{};
                currentBatch.shader = item->mat->GetShader();
                currentBatch.material = item->mat;
                currentBatch.mesh = item->model;
                currentBatch.worldMatrices.push_back(item->worldMatrix);
                currentBatch.instanceCount = 1;
            }
        }
        
        // æ·»åŠ æœ€åä¸€ä¸ªæ‰¹æ¬¡
        batches.push_back(currentBatch);
        
        // ============================================
        // æ­¥éª¤3ï¼šç»Ÿè®¡
        // ============================================
        mStats.originalDrawCalls = visibleItems.size();
        mStats.batchCount = batches.size();
        mStats.batchingRate = 1.0f - (float)batches.size() / visibleItems.size();
        
        auto endTime = std::chrono::high_resolution_clock::now();
        mStats.batchingTime = std::chrono::duration<float, std::milli>(
            endTime - startTime).count();
        mStats.strategyName = GetName();
        
        return batches;
    }
    
    BatchingStats GetStats() const override { return mStats; }
    const char* GetName() const override { return "SRP Batching"; }
    
private:
    BatchingStats mStats;
};
```

### **2.5 æ‰¹å¤„ç†ç®¡ç†å™¨**

```cpp
/// <summary>
/// æ‰¹å¤„ç†ç®¡ç†å™¨ - ç»Ÿä¸€å…¥å£
/// </summary>
class RenderBatchManager
{
public:
    /// <summary>
    /// æ„å»ºæ‰¹æ¬¡ï¼ˆè‡ªåŠ¨é€‰æ‹©ç­–ç•¥ï¼‰
    /// </summary>
    static std::vector<RenderBatch> BuildBatches(
        const std::vector<VisibleItem*>& visibleItems)
    {
        auto* settings = RenderSettings::GetInstance();
        
        // é€‰æ‹©ç­–ç•¥
        IBatchingStrategy* strategy = SelectStrategy(settings);
        
        // æ‰§è¡Œæ‰¹å¤„ç†
        auto batches = strategy->BuildBatches(visibleItems);
        
        // è®°å½•ç»Ÿè®¡
        s_CurrentStats = strategy->GetStats();
        RenderStatsManager::GetInstance()->RecordBatchingStats(s_CurrentStats);
        
        return batches;
    }
    
    /// <summary>
    /// è·å–æœ€è¿‘ä¸€æ¬¡æ‰¹å¤„ç†çš„ç»Ÿè®¡ä¿¡æ¯
    /// </summary>
    static const BatchingStats& GetStats() { return s_CurrentStats; }
    
private:
    static IBatchingStrategy* SelectStrategy(RenderSettings* settings)
    {
        if (settings->enableSRPBatch)
        {
            return &s_SRPBatchStrategy;
        }
        else
        {
            return &s_NoBatchStrategy;
        }
    }
    
private:
    static NoBatchingStrategy s_NoBatchStrategy;
    static SRPBatchingStrategy s_SRPBatchStrategy;
    static BatchingStats s_CurrentStats;
};

// é™æ€æˆå‘˜åˆå§‹åŒ–
NoBatchingStrategy RenderBatchManager::s_NoBatchStrategy;
SRPBatchingStrategy RenderBatchManager::s_SRPBatchStrategy;
BatchingStats RenderBatchManager::s_CurrentStats;
```

---

## ğŸ“¦ æ¨¡å—3ï¼šæ¸²æŸ“è®¾ç½®ç®¡ç†

### **3.1 RenderSettings é…ç½®ç±»**

```cpp
// Runtime/Renderer/RenderSettings.h
namespace EngineCore
{
    /// <summary>
    /// æ¸²æŸ“è®¾ç½® - å…¨å±€å•ä¾‹
    /// æ§åˆ¶æ‰€æœ‰æ¸²æŸ“ä¼˜åŒ–çš„å¼€å…³
    /// </summary>
    class RenderSettings
    {
    public:
        static RenderSettings* GetInstance()
        {
            static RenderSettings instance;
            return &instance;
        }
        
        // ============================================
        // Culling è®¾ç½®
        // ============================================
        bool enableFrustumCulling = true;
        bool enableMultithreadCulling = true;
        int cullingThreadCount = 4;  // å‰”é™¤çº¿ç¨‹æ•°ï¼ˆé»˜è®¤4ï¼‰
        
        // ============================================
        // Batching è®¾ç½®
        // ============================================
        bool enableSRPBatch = true;
        bool enableGPUInstancing = true;
        bool enableMaterialSorting = true;
        
        // ============================================
        // è°ƒè¯•ç»˜åˆ¶è®¾ç½®
        // ============================================
        bool drawAABB = false;
        bool drawFrustum = false;
        bool drawOnlyVisibleAABB = true;
        
        // ============================================
        // æ€§èƒ½æ¨¡å¼é¢„è®¾
        // ============================================
        enum class PerformanceMode
        {
            Normal,              // æ‰€æœ‰ä¼˜åŒ–å…³é—­ï¼ˆåŸºå‡†ï¼‰
            FrustumCullingOnly,  // åªå¯ç”¨Frustumå‰”é™¤
            MultithreadOnly,     // Frustum + å¤šçº¿ç¨‹
            BatchingOnly,        // Frustum + Batching
            FullOptimization     // æ‰€æœ‰ä¼˜åŒ–å¼€å¯
        };
        PerformanceMode currentMode = PerformanceMode::FullOptimization;
        
        /// <summary>
        /// åº”ç”¨æ€§èƒ½æ¨¡å¼é¢„è®¾
        /// </summary>
        void ApplyPerformanceMode(PerformanceMode mode)
        {
            currentMode = mode;
            
            switch (mode)
            {
            case PerformanceMode::Normal:
                // åŸºå‡†æµ‹è¯•ï¼šæ‰€æœ‰ä¼˜åŒ–å…³é—­
                enableFrustumCulling = false;
                enableMultithreadCulling = false;
                enableSRPBatch = false;
                enableGPUInstancing = false;
                break;
                
            case PerformanceMode::FrustumCullingOnly:
                // åªå¯ç”¨å•çº¿ç¨‹Frustumå‰”é™¤
                enableFrustumCulling = true;
                enableMultithreadCulling = false;
                enableSRPBatch = false;
                enableGPUInstancing = false;
                break;
                
            case PerformanceMode::MultithreadOnly:
                // Frustumå‰”é™¤ + å¤šçº¿ç¨‹
                enableFrustumCulling = true;
                enableMultithreadCulling = true;
                enableSRPBatch = false;
                enableGPUInstancing = false;
                break;
                
            case PerformanceMode::BatchingOnly:
                // å•çº¿ç¨‹å‰”é™¤ + æ‰¹å¤„ç†
                enableFrustumCulling = true;
                enableMultithreadCulling = false;
                enableSRPBatch = true;
                enableGPUInstancing = true;
                break;
                
            case PerformanceMode::FullOptimization:
                // æ‰€æœ‰ä¼˜åŒ–å¼€å¯
                enableFrustumCulling = true;
                enableMultithreadCulling = true;
                enableSRPBatch = true;
                enableGPUInstancing = true;
                break;
            }
        }
        
        /// <summary>
        /// è·å–æ¨¡å¼åç§°
        /// </summary>
        static const char* GetModeName(PerformanceMode mode)
        {
            switch (mode)
            {
                case PerformanceMode::Normal: 
                    return "Normal (No Optimization)";
                case PerformanceMode::FrustumCullingOnly: 
                    return "Frustum Culling Only";
                case PerformanceMode::MultithreadOnly: 
                    return "+ Multithread Culling";
                case PerformanceMode::BatchingOnly: 
                    return "+ SRP Batching";
                case PerformanceMode::FullOptimization: 
                    return "Full Optimization";
                default: 
                    return "Unknown";
            }
        }
    };
}
```

---

## ğŸ“¦ æ¨¡å—4ï¼šæ¸²æŸ“ç®¡çº¿é›†æˆ

### **4.1 RenderEngine æµç¨‹**

```cpp
// Runtime/Renderer/RenderEngine.cpp
void RenderEngine::Render()
{
    Camera* cam = SceneManager::GetInstance()->GetCurrentScene()->mainCamera;
    
    // ============================================
    // æ­¥éª¤1ï¼šCullingï¼ˆå¯æ’æ‹”ç­–ç•¥ï¼‰
    // ============================================
    Culling::Run(cam, renderContext);
    
    // è·å–å¯è§ç‰©ä½“åˆ—è¡¨
    // renderContext.cameraVisibleItems å·²å¡«å……
    
    // ============================================
    // æ­¥éª¤2ï¼šæ¸²æŸ“ï¼ˆPassç³»ç»Ÿï¼‰
    // ============================================
    Renderer::GetInstance()->Render(renderContext);
}
```

### **4.2 Renderer æäº¤æµç¨‹**

```cpp
// Runtime/Renderer/Renderer.cpp
void Renderer::Submit(const RenderPassInfo& info)
{
    ConfigureRenderTarget(info);
    SetViewPort(info.viewportStartPos, info.viewportEndPos);
    
    // ============================================
    // æ­¥éª¤1ï¼šBatchingï¼ˆå¯æ’æ‹”ç­–ç•¥ï¼‰
    // ============================================
    const auto& visibleItems = info.visibleItems;  // ä»Passä¼ å…¥
    auto batches = RenderBatchManager::BuildBatches(visibleItems);
    
    // ============================================
    // æ­¥éª¤2ï¼šæ¸²æŸ“æ‰¹æ¬¡
    // ============================================
    auto* settings = RenderSettings::GetInstance();
    
    for (auto& batch : batches)
    {
        // è®¾ç½®æè´¨çŠ¶æ€
        SetRenderState(batch.material, info);
        SetMaterialData(batch.material);
        SetMeshData(batch.mesh);
        
        // æ­¥éª¤3ï¼šå†³å®šæ¸²æŸ“æ–¹å¼
        if (batch.instanceCount > 1 && settings->enableGPUInstancing)
        {
            // ============================================
            // GPU Instancing è·¯å¾„
            // ============================================
            UploadInstanceBuffer(batch.worldMatrices);
            DrawIndexedInstanced(batch.mesh->GetInstanceID(), 
                                batch.instanceCount);
            
            // è®°å½•ç»Ÿè®¡
            RenderStatsManager::GetInstance()->RecordInstancedDrawCall(
                batch.mesh->GetTriangleCount() * batch.instanceCount,
                batch.mesh->GetVertexCount() * batch.instanceCount);
        }
        else
        {
            // ============================================
            // ä¼ ç»Ÿå•ç‰©ä½“æ¸²æŸ“è·¯å¾„
            // ============================================
            for (const auto& worldMatrix : batch.worldMatrices)
            {
                batch.material->SetMatrix4x4("WorldMatrix", worldMatrix);
                DrawIndexed(batch.mesh->GetInstanceID(), 1);
                
                // è®°å½•ç»Ÿè®¡
                RenderStatsManager::GetInstance()->RecordDrawCall(
                    batch.mesh->GetTriangleCount(),
                    batch.mesh->GetVertexCount());
            }
        }
    }
}
```

---

## ğŸ“Š æ¨¡å—5ï¼šæ€§èƒ½å¯¹æ¯”ç³»ç»Ÿ

### **5.1 æ€§èƒ½å¿«ç…§æ•°æ®**

```cpp
// Editor/Panel/EditorRenderOptionsPanel.h
namespace EngineEditor
{
    /// <summary>
    /// æ€§èƒ½å¿«ç…§ - ç”¨äºå¯¹æ¯”ä¸åŒæ¨¡å¼çš„æ€§èƒ½
    /// </summary>
    struct PerformanceSnapshot
    {
        std::string modeName;           // æ¨¡å¼åç§°
        
        // å¸§ç‡æ•°æ®
        float avgFPS;                   // å¹³å‡FPS
        float avgFrameTime;             // å¹³å‡å¸§æ—¶é—´ï¼ˆmsï¼‰
        
        // æ¸²æŸ“æ•°æ®
        int avgDrawCalls;               // å¹³å‡DrawCallæ•°
        int avgBatches;                 // å¹³å‡æ‰¹æ¬¡æ•°
        float avgBatchingRate;          // å¹³å‡åˆæ‰¹ç‡
        
        // å‰”é™¤æ•°æ®
        int avgVisibleObjects;          // å¹³å‡å¯è§ç‰©ä½“æ•°
        float avgCullingRate;           // å¹³å‡å‰”é™¤ç‡
        float avgCullingTime;           // å¹³å‡å‰”é™¤è€—æ—¶ï¼ˆmsï¼‰
        
        // é‡‡æ ·æ•°æ®
        int sampleCount = 0;            // é‡‡æ ·å¸§æ•°
        std::chrono::system_clock::time_point timestamp;  // æ—¶é—´æˆ³
    };
}
```

### **5.2 æ€§èƒ½å¯¹æ¯”é¢æ¿**

```cpp
// Editor/Panel/EditorRenderOptionsPanel.cpp
void EditorRenderOptionsPanel::DrawPerformanceModeSelector()
{
    auto* settings = EngineCore::RenderSettings::GetInstance();
    
    ImGui::Text("Performance Mode");
    
    const char* modes[] = {
        "Normal (No Optimization)",
        "Frustum Culling Only",
        "+ Multithread Culling",
        "+ SRP Batching",
        "Full Optimization"
    };
    
    int currentMode = (int)settings->currentMode;
    
    if (ImGui::Combo("##PerfMode", &currentMode, modes, IM_ARRAYSIZE(modes)))
    {
        // åˆ‡æ¢æ¨¡å¼
        settings->ApplyPerformanceMode(
            (EngineCore::RenderSettings::PerformanceMode)currentMode);
        
        // å¼€å§‹æ–°çš„æ€§èƒ½é‡‡æ ·
        StartNewPerformanceSampling(modes[currentMode]);
    }
    
    ImGui::SameLine();
    if (ImGui::Button("Take Snapshot"))
    {
        // ç«‹å³è®°å½•å½“å‰æ€§èƒ½å¿«ç…§
        RecordPerformanceSnapshot();
    }
    
    ImGui::SameLine();
    if (ImGui::Button("Clear History"))
    {
        mPerformanceHistory.clear();
    }
}

void EditorRenderOptionsPanel::DrawPerformanceComparison()
{
    if (mPerformanceHistory.empty())
    {
        ImGui::TextColored(ImVec4(1, 1, 0, 1), "No performance data yet.");
        ImGui::Text("Switch between different modes and take snapshots.");
        return;
    }
    
    // è¡¨æ ¼æ˜¾ç¤ºå¯¹æ¯”æ•°æ®
    if (ImGui::BeginTable("PerfCompare", 8, 
        ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable))
    {
        // è¡¨å¤´
        ImGui::TableSetupColumn("Mode");
        ImGui::TableSetupColumn("FPS");
        ImGui::TableSetupColumn("Frame Time");
        ImGui::TableSetupColumn("Draw Calls");
        ImGui::TableSetupColumn("Batches");
        ImGui::TableSetupColumn("Batching Rate");
        ImGui::TableSetupColumn("Culling Rate");
        ImGui::TableSetupColumn("Culling Time");
        ImGui::TableHeadersRow();
        
        // æ•°æ®è¡Œ
        for (const auto& snapshot : mPerformanceHistory)
        {
            ImGui::TableNextRow();
            
            ImGui::TableNextColumn();
            ImGui::Text("%s", snapshot.modeName.c_str());
            
            ImGui::TableNextColumn();
            // FPSé¢œè‰²ç¼–ç 
            ImVec4 fpsColor = snapshot.avgFPS >= 60 ? 
                ImVec4(0, 1, 0, 1) : ImVec4(1, 1, 0, 1);
            ImGui::TextColored(fpsColor, "%.1f", snapshot.avgFPS);
            
            ImGui::TableNextColumn();
            ImGui::Text("%.2f ms", snapshot.avgFrameTime);
            
            ImGui::TableNextColumn();
            ImGui::Text("%d", snapshot.avgDrawCalls);
            
            ImGui::TableNextColumn();
            ImGui::Text("%d", snapshot.avgBatches);
            
            ImGui::TableNextColumn();
            ImGui::Text("%.1f%%", snapshot.avgBatchingRate * 100.0f);
            
            ImGui::TableNextColumn();
            ImGui::Text("%.1f%%", snapshot.avgCullingRate * 100.0f);
            
            ImGui::TableNextColumn();
            ImGui::Text("%.3f ms", snapshot.avgCullingTime);
        }
        
        ImGui::EndTable();
    }
    
    // æŸ±çŠ¶å›¾å¯¹æ¯”ï¼ˆå¯é€‰ï¼‰
    if (ImGui::TreeNode("Performance Charts"))
    {
        DrawPerformanceCharts();
        ImGui::TreePop();
    }
}

void EditorRenderOptionsPanel::RecordPerformanceSnapshot()
{
    auto* statsManager = EngineCore::RenderStatsManager::GetInstance();
    auto& stats = statsManager->GetCurrentStats();
    auto* settings = EngineCore::RenderSettings::GetInstance();
    
    PerformanceSnapshot snapshot;
    snapshot.modeName = EngineCore::RenderSettings::GetModeName(settings->currentMode);
    snapshot.avgFPS = stats.fps;
    snapshot.avgFrameTime = stats.frameTime;
    snapshot.avgDrawCalls = stats.drawCallCount;
    snapshot.avgBatches = stats.batchCount;
    snapshot.avgBatchingRate = stats.batchingRate;
    snapshot.avgVisibleObjects = stats.visibleObjects;
    snapshot.avgCullingRate = stats.totalObjects > 0 ?
        (float)stats.culledObjects / stats.totalObjects : 0.0f;
    snapshot.avgCullingTime = stats.cullingTime;
    snapshot.sampleCount = 1;
    snapshot.timestamp = std::chrono::system_clock::now();
    
    mPerformanceHistory.push_back(snapshot);
    
    // é™åˆ¶å†å²æ•°é‡
    if (mPerformanceHistory.size() > 20)
    {
        mPerformanceHistory.erase(mPerformanceHistory.begin());
    }
}
```

---

## ğŸ“ˆ ä½¿ç”¨æµç¨‹ç¤ºä¾‹

### **åœºæ™¯1ï¼šæ€§èƒ½åŸºå‡†æµ‹è¯•**

```cpp
// 1. åˆ›å»ºæµ‹è¯•åœºæ™¯
auto* scene = SceneBuilder::CreateTestScene("PerfTest", 1000);

// 2. è®¾ç½®ä¸ºæ— ä¼˜åŒ–æ¨¡å¼ï¼ˆåŸºå‡†ï¼‰
RenderSettings::GetInstance()->ApplyPerformanceMode(
    RenderSettings::PerformanceMode::Normal);

// 3. è¿è¡Œ60ç§’ï¼Œè®°å½•FPS
// ...è®°å½•åŸºå‡†FPS

// 4. é€æ­¥å¯ç”¨ä¼˜åŒ–ï¼Œæ¯æ¬¡è®°å½•FPS
RenderSettings::GetInstance()->ApplyPerformanceMode(
    RenderSettings::PerformanceMode::FrustumCullingOnly);
// ...è®°å½•FPS

RenderSettings::GetInstance()->ApplyPerformanceMode(
    RenderSettings::PerformanceMode::MultithreadOnly);
// ...è®°å½•FPS

// 5. å¯¹æ¯”ç»“æœ
// åŸºå‡†ï¼š30 FPS
// +Frustumï¼š60 FPSï¼ˆ2å€æå‡ï¼‰
// +Multithreadï¼š90 FPSï¼ˆ3å€æå‡ï¼‰
// +Batchingï¼š120 FPSï¼ˆ4å€æå‡ï¼‰
```

### **åœºæ™¯2ï¼šç¼–è¾‘å™¨å®æ—¶åˆ‡æ¢**

```
ç”¨æˆ·æ“ä½œï¼š
1. Assets â†’ Create Scene â†’ Test Scene (1000 Objects)
2. æ‰“å¼€ Render Options é¢æ¿
3. åˆ‡æ¢ Performance Mode ä¸‹æ‹‰æ¡†ï¼š
   - Normal â†’ è®°å½•å¿«ç…§ â†’ FPS: 30
   - Frustum Culling Only â†’ è®°å½•å¿«ç…§ â†’ FPS: 60
   - + Multithread â†’ è®°å½•å¿«ç…§ â†’ FPS: 90
   - Full Optimization â†’ è®°å½•å¿«ç…§ â†’ FPS: 120
4. æŸ¥çœ‹ Performance Comparison è¡¨æ ¼
   - ä¸€ç›®äº†ç„¶åœ°çœ‹åˆ°æ¯ä¸ªä¼˜åŒ–çš„æ•ˆæœ
```

---

## âœ… ä¼˜åŠ¿æ€»ç»“

| æ–¹é¢ | ä¼ ç»Ÿæ–¹å¼ | å¯æ’æ‹”æ¨¡å¼ |
|------|---------|-----------|
| **å¼€å…³åˆ‡æ¢** | éœ€è¦ä¿®æ”¹ä»£ç é‡æ–°ç¼–è¯‘ | è¿è¡Œæ—¶å®æ—¶åˆ‡æ¢ |
| **æ€§èƒ½å¯¹æ¯”** | éœ€è¦å¤šæ¬¡ç¼–è¯‘æµ‹è¯• | ä¸€æ¬¡è¿è¡Œå¤šæ¬¡å¯¹æ¯” |
| **ä»£ç ä¾µå…¥** | åˆ°å¤„éƒ½æ˜¯if-elseåˆ¤æ–­ | ç­–ç•¥ç‹¬ç«‹ï¼Œé›¶ä¾µå…¥ |
| **æ˜“æ‰©å±•** | ä¿®æ”¹å¤æ‚ï¼Œå®¹æ˜“å‡ºé”™ | å®ç°æ¥å£å³å¯ |
| **æµ‹è¯•** | éš¾ä»¥éš”ç¦»æµ‹è¯• | æ¯ä¸ªç­–ç•¥ç‹¬ç«‹æµ‹è¯• |
| **ç»´æŠ¤** | è€¦åˆä¸¥é‡ï¼Œéš¾ç»´æŠ¤ | æ¨¡å—åŒ–ï¼Œæ˜“ç»´æŠ¤ |

---

## ğŸ“ æ€»ç»“

é€šè¿‡**ç­–ç•¥æ¨¡å¼ + ç®¡çº¿åŒ–**è®¾è®¡ï¼Œæˆ‘ä»¬å®ç°äº†ï¼š

1. âœ… **3ç§Cullingç­–ç•¥**ï¼šæ— å‰”é™¤ã€å•çº¿ç¨‹ã€å¤šçº¿ç¨‹
2. âœ… **2ç§Batchingç­–ç•¥**ï¼šæ— æ‰¹å¤„ç†ã€SRP Batch
3. âœ… **è¿è¡Œæ—¶åˆ‡æ¢**ï¼šä¸éœ€è¦é‡æ–°ç¼–è¯‘
4. âœ… **æ€§èƒ½å¯¹æ¯”**ï¼šå¯è§†åŒ–å¯¹æ¯”ä¸åŒä¼˜åŒ–çš„æ•ˆæœ
5. âœ… **æ˜“äºæ‰©å±•**ï¼šæ–°å¢ç­–ç•¥åªéœ€å®ç°æ¥å£

è¿™å¥—ç³»ç»Ÿæ—¢èƒ½å¸®åŠ©æˆ‘ä»¬**è°ƒè¯•ä¼˜åŒ–æ•ˆæœ**ï¼Œåˆèƒ½è®©æˆ‘ä»¬**å¿«é€ŸéªŒè¯æ–°ç­–ç•¥**ï¼Œæ˜¯ä¸€å¥—éå¸¸å®ç”¨çš„æ¶æ„è®¾è®¡ã€‚

---

**æ–‡æ¡£å®Œ**  
ç¥å¼€å‘é¡ºåˆ©ï¼ğŸš€

