# 渲染模式与多帧同步笔记

目标：整理当前渲染模式、演进到多帧/多队列的设计思路，以及我们在理解过程中卡住的点和澄清，便于后续复习与统一认识。

## 1. 当前渲染模式（单帧锁步）

- 主线程执行 Scene/Culling 等渲染逻辑，生成渲染数据并提交给渲染线程。
- 渲染线程录制命令并提交 GPU。
- CPU/GPU 在帧末等待，上一帧完全结束后进入下一帧。

结论：本质是单帧锁步，吞吐低，CPU 常空转。

## 2. 前置概念（必须统一理解）

- Staging/Upload Buffer：CPU 可写的中转区，每帧把脏数据写入这里，再由 GPU Copy 到 Default Buffer。
- FrameContext：每帧独立的临时资源集合（staging、动态 descriptor、allocator、command allocator 等）。
- Fence：标记 GPU 执行进度，保证 CPU 复用临时资源时安全。
- 数据撕裂：GPU 正在读取资源时，另一个队列写入同一资源导致读写重叠。

## 3. 单队列多帧（3 帧 in-flight）

GPU 执行顺序固定：Copy N -> Draw N -> Copy N+1 -> Draw N+1 ...

CPU 侧：
- 3 个 FrameContext 轮转。
- 不需要每帧等待 GPU，只在复用某个 FrameContext 时等待其 fence。

数据安全原因：
- staging 各帧独立。
- GPU 单队列串行执行，Copy 与 Draw 不重叠。

收益：
- 减少 CPU 等待 GPU 的空转时间。
- 帧吞吐提升。

代价：
- GPU 上 Copy 与 Draw 仍然串行。
- 输入延迟增加（帧队列变长）。

## 4. 多队列（Graphics + Copy）

目标：让 Copy 与 Draw 并行，减少 GPU 队列阻塞。

风险：
- Copy queue 提前写入资源，而 Graphics queue 仍在读 -> 数据撕裂/闪烁。

安全策略：
1) 强同步（安全但可能 stall）
   - Graphics signal fence -> Copy wait -> Copy 完成 signal -> Graphics wait
2) 三份动态数据（高性能，内存换并行）
   - 高频动态数据做 3 份（例如 objectDataBuffer[3]）
   - 每帧使用自己的版本，避免读写重叠

结论：
- 多队列能减少 GPU 时间，但同步复杂度更高。
- 若不想强同步，需要三份动态数据隔离。

## 5. 常见误区与澄清（我们卡住的点）

1) CPU 修改数据会影响 GPU 正在画的上一帧吗？
- 单队列不会，因为 GPU 执行顺序固定，Copy N+1 不会在 Draw N 前执行。

2) Set/Bind 会立即读取资源吗？
- 不会。Set/Bind 只是录入命令，GPU 在执行 Draw 时才读取资源。

3) 为什么需要 staging？
- Default Buffer 不能被 CPU 直接写入，必须通过 staging 作为中转。

4) 多帧一定要每帧 wait fence 吗？
- 不需要。只在复用 FrameContext 时等待对应 fence。

5) N+2 的 Copy 会不会在 N+1 Draw 期间覆盖数据？
- 单队列不会发生，队列顺序保证了 Copy/Draw 串行。

6) 数据撕裂什么时候发生？
- 只有在 GPU 正在读时，另一个队列写同一资源导致读写重叠。

## 6. 设计方向总结

- 先做单队列多帧（3 FrameContext），解决 CPU 等待问题。
- 再引入 copy queue，先用强同步验证正确性。
- 性能需求更高时，迁移到“三份动态数据”以减少同步等待。

