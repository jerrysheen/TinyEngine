# 组件工厂架构说明

## 问题背景

当前引擎中，游戏脚本（如 `RotateGameObject`）在 `GameCore` 命名空间中，但如果使用模板方式 `AddComponent<RotateGameObject>()`，就需要在编译期知道这个类型，导致游戏逻辑和引擎耦合。

**问题**：
```cpp
// 现在的方式 - 编译期绑定，GameCore 和 EngineCore 耦合
auto* script = gameObject->AddComponent<GameCore::RotateGameObject>();
```

**理想方式**：
```cpp
// 运行时动态加载 - 通过字符串名称，解耦引擎和游戏逻辑
auto* script = gameObject->AddComponentByName("RotateGameObject");
```

---

## 解决方案：组件工厂 + 反射系统

### 核心设计

#### 1. **ComponentFactory（组件工厂）**
- 维护一个 `<字符串类型名, 创建函数>` 的映射表
- 通过字符串名称动态创建组件实例
- 位置：`Runtime/GameObject/ComponentFactory.h`

#### 2. **组件注册宏 `REGISTER_COMPONENT`**
- 每个游戏脚本在自己的 `.cpp` 文件中注册
- 程序启动时自动执行注册
- 无需修改引擎代码

#### 3. **JSON场景序列化**
- 场景文件保存组件类型名称（字符串）
- `SceneSerializer` 加载时通过工厂创建组件

---

## 完整工作流程

### 阶段1：编译期 - 脚本注册

```cpp
// Runtime/Scripts/RotateGameObject.cpp

#include "RotateGameObject.h"
#include "GameObject/ComponentFactory.h"

namespace GameCore {
    // ... RotateGameObject 的实现 ...
}

// 【关键】注册组件到工厂
// 这行代码会在 main() 之前自动执行（C++ 全局对象构造）
REGISTER_COMPONENT(GameCore::RotateGameObject)
```

**原理**：
- 宏展开后创建一个全局静态对象
- 该对象的构造函数会调用 `ComponentFactory::RegisterComponent`
- 在 `main()` 函数执行前完成所有注册

### 阶段2：运行时 - JSON加载场景

```json
// Assets/Scenes/ExampleScene.json
{
  "sceneName": "ExampleScene",
  "gameObjects": [
    {
      "name": "RotatingCube",
      "components": [
        {
          "type": "GameCore::RotateGameObject",  // 字符串类型名
          "data": "0,90,0"                       // 序列化数据
        }
      ]
    }
  ]
}
```

### 阶段3：运行时 - 创建组件

```cpp
// SceneSerializer 伪代码
void SceneSerializer::LoadFromJSON(Scene* scene, const std::string& filePath)
{
    // 1. 解析JSON
    json sceneData = ParseJSON(filePath);
    
    // 2. 遍历GameObject
    for (auto& goData : sceneData["gameObjects"])
    {
        GameObject* go = scene->CreateGameObject(goData["name"]);
        
        // 3. 遍历组件
        for (auto& compData : goData["components"])
        {
            std::string typeName = compData["type"];  // "GameCore::RotateGameObject"
            
            // 4. 通过工厂创建组件（运行时动态）
            Component* comp = go->AddComponentByName(typeName);
            
            // 5. 反序列化组件数据
            if (comp)
            {
                MonoBehaviour* script = dynamic_cast<MonoBehaviour*>(comp);
                script->Deserialize(compData["data"]);  // "0,90,0"
            }
        }
    }
}
```

### 阶段4：运行时 - Scene驱动更新

```cpp
// Scene::Update()
void Scene::Update()
{
    for (auto* go : allObjList)
    {
        for (auto* script : go->scripts)  // 遍历所有脚本
        {
            // 第一帧调用 Start
            if (!script->m_IsStarted)
            {
                script->Start();
                script->m_IsStarted = true;
            }
            
            // 每帧调用 Update
            script->Update();  // 多态调用 → RotateGameObject::Update()
        }
    }
}
```

---

## 代码实现

### 1. ComponentFactory.h

```cpp
class ComponentFactory
{
public:
    static ComponentFactory& GetInstance();
    
    // 注册组件类型
    void RegisterComponent(const std::string& typeName, ComponentCreator creator);
    
    // 通过名称创建组件
    Component* CreateComponent(const std::string& typeName, GameObject* go);
    
private:
    std::unordered_map<std::string, ComponentCreator> m_Creators;
};

// 注册宏
#define REGISTER_COMPONENT(ComponentClass) \
    namespace { \
        static ComponentRegistrar g_##ComponentClass##_Registrar( \
            #ComponentClass, \
            [](GameObject* go) { return new ComponentClass(go); } \
        ); \
    }
```

### 2. GameObject::AddComponentByName

```cpp
Component* GameObject::AddComponentByName(const std::string& typeName)
{
    // 通过工厂创建
    Component* comp = ComponentFactory::GetInstance().CreateComponent(typeName, this);
    
    // 如果是 MonoBehaviour，加入 scripts 列表
    if (MonoBehaviour* script = dynamic_cast<MonoBehaviour*>(comp))
    {
        scripts.push_back(script);
    }
    
    return comp;
}
```

### 3. 游戏脚本实现

```cpp
// RotateGameObject.h
namespace GameCore
{
    class RotateGameObject : public EngineCore::MonoBehaviour
    {
    public:
        RotateGameObject(EngineCore::GameObject* go);
        
        virtual void Start() override;
        virtual void Update() override;
        
        // 序列化支持
        virtual std::string Serialize() override;
        virtual void Deserialize(const std::string& data) override;
        
    public:
        EngineCore::Vector3 rotationSpeed{0, 90, 0};  // 度/秒
    };
}

// RotateGameObject.cpp
namespace GameCore
{
    void RotateGameObject::Update()
    {
        float dt = Game::GetDeltaTime();
        Vector3 rotation = rotationSpeed * dt;
        gameObject->transform->Rotate(rotation);
    }
}

// 【关键】注册到工厂
REGISTER_COMPONENT(GameCore::RotateGameObject)
```

---

## 使用示例

### 方式1：代码创建（开发/测试）

```cpp
GameObject* cube = scene->CreateGameObject("MyCube");

// 动态添加脚本
cube->AddComponentByName("GameCore::RotateGameObject");

// Scene 更新会自动调用脚本的 Update
scene->Update();
```

### 方式2：JSON加载（生产环境）

```cpp
// 从文件加载场景
SceneSerializer::LoadFromJSON(scene, "Assets/Scenes/Level1.json");

// 场景中的所有 GameObject 和脚本已创建完毕
scene->Update();
```

---

## 优势

### ✅ 解耦引擎和游戏逻辑
- `EngineCore` 不需要知道 `GameCore` 的任何类型
- 引擎编译后，可以独立添加新脚本（只需重新编译游戏层）

### ✅ 数据驱动
- 场景配置在 JSON 文件中
- 策划/设计师可以直接修改场景配置，无需编程

### ✅ 序列化友好
- 保存场景时记录组件类型名称
- 加载场景时通过工厂还原

### ✅ 扩展性强
- 添加新脚本只需：
  1. 创建脚本类（继承 MonoBehaviour）
  2. 在 .cpp 文件末尾添加 `REGISTER_COMPONENT(YourScript)`
  3. 完成！

---

## 对比 Unity 的设计

| Unity | TinyEngine（本方案） |
|-------|---------------------|
| C# 反射 | C++ 组件工厂 + 宏 |
| `AddComponent("RotateScript")` | `AddComponentByName("GameCore::RotateGameObject")` |
| Prefab序列化 | JSON场景序列化 |
| Inspector编辑 | JSON文件编辑（后续可做可视化编辑器） |

---

## 后续扩展方向

### 1. 完整的JSON序列化
- 集成 `nlohmann/json` 库
- 支持复杂数据类型序列化

### 2. 热重载支持
- 动态链接库（DLL/SO）加载游戏逻辑
- 修改脚本后无需重启引擎

### 3. 可视化编辑器
- Inspector 面板显示脚本参数
- 拖拽添加组件

### 4. Prefab 系统
- GameObject 模板
- 实例化和覆写机制

---

## 关键文件清单

```
Runtime/
├── GameObject/
│   ├── ComponentFactory.h          # 组件工厂（核心）
│   ├── ComponentFactory.cpp
│   ├── GameObject.h                # AddComponentByName 方法
│   ├── GameObject.cpp
│   └── MonoBehaviour.h             # 脚本基类
├── Scene/
│   ├── Scene.h                     # Scene::Update 驱动脚本
│   ├── Scene.cpp
│   ├── SceneSerializer.h           # JSON 加载（TODO）
│   └── SceneSerializer.cpp
└── Scripts/                         # 游戏脚本目录
    ├── RotateGameObject.h
    └── RotateGameObject.cpp        # 末尾：REGISTER_COMPONENT

Assets/
└── Scenes/
    └── ExampleScene.json           # 场景配置
```

---

## 总结

这个架构实现了：
1. ✅ **编译期**：通过宏自动注册组件
2. ✅ **运行时**：通过字符串名称动态创建组件
3. ✅ **数据驱动**：通过JSON配置场景
4. ✅ **解耦设计**：引擎不依赖游戏代码

**你的理解是完全正确的**：
> JSON文件读取 → AddComponent到GameObject → Scene更新驱动

这正是现代游戏引擎（Unity、Unreal）的核心架构思想！

